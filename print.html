<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>React-Node.js</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="day01/index.html"><strong aria-hidden="true">1.</strong> Day01</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day01/about-react.html"><strong aria-hidden="true">1.1.</strong> Reactとは</a></li><li class="chapter-item expanded "><a href="day01/construct-app.html"><strong aria-hidden="true">1.2.</strong> アプリケーション実装の準備</a></li><li class="chapter-item expanded "><a href="day01/use-component.html"><strong aria-hidden="true">1.3.</strong> コンポーネント</a></li><li class="chapter-item expanded "><a href="day01/use-props.html"><strong aria-hidden="true">1.4.</strong> propsの活用</a></li><li class="chapter-item expanded "><a href="day01/use-router.html"><strong aria-hidden="true">1.5.</strong> router機能</a></li><li class="chapter-item expanded "><a href="day01/props-function.html"><strong aria-hidden="true">1.6.</strong> 子コンポーネントへの関数入力</a></li><li class="chapter-item expanded "><a href="day01/http-request.html"><strong aria-hidden="true">1.7.</strong> httpリクエストの実装</a></li><li class="chapter-item expanded "><a href="day01/ui.html"><strong aria-hidden="true">1.8.</strong> 表示の調整</a></li><li class="chapter-item expanded "><a href="day01/work.html"><strong aria-hidden="true">1.9.</strong> 課題（任意）</a></li></ol></li><li class="chapter-item expanded "><a href="day02/index.html"><strong aria-hidden="true">2.</strong> Day02</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day02/about-nodejs.html"><strong aria-hidden="true">2.1.</strong> Node.js とは</a></li><li class="chapter-item expanded "><a href="day02/prepare-api.html"><strong aria-hidden="true">2.2.</strong> API 実装の準備</a></li><li class="chapter-item expanded "><a href="day02/install-express.html"><strong aria-hidden="true">2.3.</strong> Expressのインストール</a></li><li class="chapter-item expanded "><a href="day02/omikuji-api01.html"><strong aria-hidden="true">2.4.</strong> API実装1（おみくじ初級編）</a></li><li class="chapter-item expanded "><a href="day02/add-command.html"><strong aria-hidden="true">2.5.</strong> コマンドの追加</a></li><li class="chapter-item expanded "><a href="day02/omikuji-api02.html"><strong aria-hidden="true">2.6.</strong> API実装2（おみくじ中級編）</a></li><li class="chapter-item expanded "><a href="day02/janken-api.html"><strong aria-hidden="true">2.7.</strong> API実装3（じゃんけん）</a></li><li class="chapter-item expanded "><a href="day02/summary.html"><strong aria-hidden="true">2.8.</strong> まとめ</a></li></ol></li><li class="chapter-item expanded "><a href="day03/index.html"><strong aria-hidden="true">3.</strong> Day03</a></li><li class="chapter-item expanded "><a href="day04/index.html"><strong aria-hidden="true">4.</strong> Day04</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">React-Node.js</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day01"><a class="header" href="#day01">Day01</a></h1>
<h2 id="今回のゴール"><a class="header" href="#今回のゴール">今回のゴール</a></h2>
<ul>
<li>React の基本的な処理を知り，実装を行う．</li>
<li>コンポーネントの組み合わせやデータの受け渡しを理解する．</li>
<li>外部との通信を実装し，データの扱い方や注意点を理解する．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="reactとは"><a class="header" href="#reactとは">Reactとは</a></h1>
<ul>
<li>ユーザインターフェース構築のための JavaScript ライブラリ</li>
</ul>
<h2 id="宣言的な-view"><a class="header" href="#宣言的な-view">宣言的な View</a></h2>
<ul>
<li>React は、インタラクティブなユーザインターフェイスの作成にともなう苦痛を取り除きます．アプリケーションの各状態に対応するシンプルな View を設計するだけで，React はデータの変更を検知し，関連するコンポーネントだけを効率的に更新，描画します．</li>
<li>宣言的な View を用いてアプリケーションを構築することで，コードはより見通しが立ちやすく，デバッグのしやすいものになります．</li>
</ul>
<h2 id="コンポーネントベース"><a class="header" href="#コンポーネントベース">コンポーネントベース</a></h2>
<ul>
<li>自分自身の状態を管理するカプセル化されたコンポーネントをまず作成し，これらを組み合わせることで複雑なユーザインターフェイスを構築します．</li>
<li>コンポーネントのロジックは，Template ではなく JavaScript そのもので書くことができるので，様々なデータをアプリケーション内で簡単に取り回すことができ，かつ DOM に状態を持たせないようにすることができます．</li>
</ul>
<h2 id="一度学習すればどこでも使える"><a class="header" href="#一度学習すればどこでも使える">一度学習すれば、どこでも使える</a></h2>
<ul>
<li>React と組み合わせて使用する技術に制限はありません．React を使って新しい機能を追加する際に，既存のソースコードを書き換える必要はありません．</li>
<li>React は Node を使ったサーバー上でもレンダーできますし，React Native を使うことでモバイルアプリケーションの中でも動きます．</li>
</ul>
<h2 id="で結局なんなのじゃ"><a class="header" href="#で結局なんなのじゃ">で，結局なんなのじゃ？</a></h2>
<ul>
<li>描画などの面倒な処理をいい感じにやってくれる．</li>
<li>画面に表示したいパーツ（コンポーネント）ごとに記述するので他の部分に影響しづらく，使い回しが効く．</li>
<li>ライブラリが充実しているのでだいたいのことはわりと簡単にできる．</li>
</ul>
<h2 id="今回作成するアプリケーション"><a class="header" href="#今回作成するアプリケーション">今回作成するアプリケーション</a></h2>
<ul>
<li>オススメ本を表示する SPA．</li>
<li>ページごとにカテゴリ別の本が一覧で表示される．</li>
<li>本のデータ Google books API から読み込んで表示する．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="アプリケーション実装の準備"><a class="header" href="#アプリケーション実装の準備">アプリケーション実装の準備</a></h1>
<h2 id="必要なツールのバージョン確認"><a class="header" href="#必要なツールのバージョン確認">必要なツールのバージョン確認</a></h2>
<ul>
<li>Node.js と npm が必要なので，以下のコマンドで状況を確認する．</li>
<li>バージョンが表示されれば OK．</li>
</ul>
<pre><code class="language-bash">$ node -v
v14.15.3
$ npm -v
7.15.0
</code></pre>
<h2 id="プロジェクトの作成"><a class="header" href="#プロジェクトの作成">プロジェクトの作成</a></h2>
<ul>
<li>React はプロジェクト単位でアプリケーションを開発する．</li>
<li>専用のコマンドが用意されているので，以下のようにプロジェクトを作成する．</li>
<li><code>npx</code>を使用すると，インストールしていないパッケージを実行できる．グローバルに残らないので，汚染の心配がない．</li>
<li>最後の<code>react-app</code>はプロジェクト名なので好きな名前で OK．</li>
</ul>
<pre><code class="language-bash">$ npx create-react-app react-app
</code></pre>
<p>※<code>npm</code>ではなく<code>npx</code>である点に注意！</p>
<p>いい感じにできたら，以下のコマンドでディレクトリに移動し，サーバを起動する．</p>
<pre><code class="language-bash">$ cd react-app
$ npm start
</code></pre>
<p>自動的にブラウザが立ち上がり，以下のような画面が表示されれば OK．</p>
<p><img src="day01/./img/firstview.png" alt="初期画面の画像" /></p>
<p>サーバはターミナル上で<code>control + c</code>すると停止できる．</p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>React の開発手順について</p>
<ul>
<li><code>npm start</code>を実行した状態でファイルを編集すると自動的にコンパイルが行われ，最新の状態がブラウザ画面に反映される．</li>
<li><code>npm start</code>実行 -&gt; vs code でコード編集 -&gt; ブラウザで動作確認 の繰り返し．</li>
<li>ライブラリ追加時などはサーバを再起動しないと反映されないため．動作しない場合は<code>control + c</code>して再度<code>npm start</code>でサーバを起動する．</li>
</ul>
</blockquote>
<h2 id="react-の大まかな仕組み"><a class="header" href="#react-の大まかな仕組み">React の大まかな仕組み</a></h2>
<ul>
<li>アプリケーションは全て<code>public/index.html</code>上で実行される．</li>
<li>実行時には<code>src/index.js</code>が実行され，<code>App</code>コンポーネントが<code>index.html</code>上にマウントされる．</li>
<li>実際に画面に表示されるのは<code>App.js</code>内に記述された内容となる．</li>
<li>この<code>App.js</code>から様々なコンポーネントを読み込むことでアプリケーションが動作する．</li>
</ul>
<h2 id="メイン画面の編集と不要なファイルの削除"><a class="header" href="#メイン画面の編集と不要なファイルの削除">メイン画面の編集と不要なファイルの削除</a></h2>
<p>メインの画面は<code>App.js</code>であり，このファイルが<code>index.html</code>の<code>id=root</code>に描画される．</p>
<p>初期状態では<code>App.js</code>に不要な記述が含まれているため削除する．合わせて使用しないファイルも削除する．</p>
<p><code>App.js</code>のファイル名を<code>App.jsx</code>に変更し，内容を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx
import React from &quot;react&quot;;

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>以下のファイルを削除する．</p>
<ul>
<li><code>src/App.css</code></li>
<li><code>src/App.test.js</code></li>
<li><code>src/logo.svg</code></li>
</ul>
<p>また，<code>index.js</code>の内容を以下のように編集する．</p>
<pre><code class="language-js">// index.js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import reportWebVitals from './reportWebVitals';

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById('root')
);

reportWebVitals();

</code></pre>
<p>以下のコマンドで開発サーバを起動する．</p>
<pre><code class="language-bash">$ npm start
</code></pre>
<p>ブラウザ画面を確認すると以下のようになっている．
<img src="day01/./img/mainview01.png" alt="メイン画面1" /></p>
<blockquote>
<p>【補足】js と jsx</p>
<ul>
<li>js：Javascript のファイル．</li>
<li>jsx：React 要素を生成する Javascript の拡張．React ではこちらを使うとたくさんいいことがある．</li>
</ul>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="コンポーネント"><a class="header" href="#コンポーネント">コンポーネント</a></h1>
<p>ここから，実際にコンポーネントを実装してみる．</p>
<p>まずは必要なファイルを準備しよう．</p>
<ul>
<li><code>src</code>ディレクトリに<code>components</code>ディレクトリを作成する．</li>
<li><code>components</code>ディレクトリ内に<code>Booklist.jsx</code>を作成する．</li>
<li><code>Booklist.jsx</code>に以下の内容を記述する．</li>
</ul>
<pre><code class="language-jsx">// Booklist.jsx
import React from &quot;react&quot;;

export const Booklist = (props) =&gt; {
  return (
    &lt;&gt;
      &lt;p&gt;this is book list component&lt;/p&gt;
    &lt;/&gt;
  );
};

</code></pre>
<blockquote>
<p>【解説】コンポーネントの作成</p>
<ul>
<li>コンポーネントには「class コンポーネント」と「関数コンポーネント」の 2 種類が存在する．</li>
<li>class コンポーネントは「状態を持つことができる（ステートフル）」という特徴があるが，関数コンポーネントでは「状態を持つことができない（ステートレス）」．</li>
<li>しかし，関数コンポーネントでも「React hooks」という技術を使うことで同様の振る舞いを実現することができる．</li>
<li>「state」というのはコンポーネント自体が持つ値であり，他にコンポーネントが外から受け取る「props」が存在する．</li>
<li>コンポーネント作成の際には，できるだけ state を持たないよう設計すると動作確認が楽になるだけでなく，バグの生まれる可能性も低減できる．</li>
<li>そのため，本記事ではすべて関数コンポーネントを使用してアプリケーションを構築し，必要に応じて「React hooks」を使用して状態を管理する．</li>
</ul>
</blockquote>
<h2 id="コンポーネントの構造"><a class="header" href="#コンポーネントの構造">コンポーネントの構造</a></h2>
<ul>
<li><code>import ...</code>は必要なライブラリを読み込む．</li>
<li>関数<code>Booklist</code>は呼び出し元のコンポーネントから<code>props</code>を受け取り，html要素を出力する．</li>
<li><code>export const Booklist = ...</code>とすることで，他のコンポーネントから<code>import { Booklist } ...</code>のように記述して呼び出せるようにしている．</li>
</ul>
<h2 id="コンポーネントの呼び出し1"><a class="header" href="#コンポーネントの呼び出し1">コンポーネントの呼び出し（1）</a></h2>
<p><code>Booklist</code>コンポーネントを作成したので，<code>App</code>コンポーネントから呼び出してみる．</p>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx
import React from &quot;react&quot;;
import { Booklist } from &quot;./components/Booklist&quot;; // 追加（コンポーネントのimport）

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist /&gt;
    &lt;/&gt;
  );
};
export default App;

</code></pre>
<p>ブラウザで表示を確認すると以下のようになっている．</p>
<p><img src="day01/./img/mainview02.png" alt="メイン画面2" /></p>
<p>また，検証画面を確認すると，以下のように Booklist コンポーネントが読み込まれていることがわかる．</p>
<p><img src="day01/./img/elements01.png" alt="検証画面1" /></p>
<h2 id="コンポーネントの呼び出し2"><a class="header" href="#コンポーネントの呼び出し2">コンポーネントの呼び出し（2）</a></h2>
<p>呼び出すコンポーネントを 2 つにしてみる．</p>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx
import React from &quot;react&quot;;
import { Booklist } from &quot;./components/Booklist&quot;;

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist /&gt;
      &lt;Booklist /&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>ブラウザ画面で，<code>Booklist</code>コンポーネントが 2 つ表示されていることを確認しよう．</p>
<p>このように，作成したコンポーネントは複数使用することもできる．</p>
<p><img src="day01/./img/mainview03.png" alt="メイン画面3" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="propsの活用"><a class="header" href="#propsの活用">propsの活用</a></h1>
<p><code>props</code>は呼び出し元のコンポーネント（親コンポーネント）から呼び出されたコンポーネント（子コンポーネント）に渡されるデータの塊である．</p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>Reactのコンポーネントは「関数」であり，入力と出力がある．「入力」に当たるのがこの<code>props</code>である．</p>
</blockquote>
<h2 id="propsでデータを渡す"><a class="header" href="#propsでデータを渡す"><code>props</code>でデータを渡す</a></h2>
<p>実際に<code>App</code>コンポーネントから<code>Booklist</code>コンポーネントに文字列のデータを渡してみよう．</p>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx
import React from &quot;react&quot;;
import { Booklist } from &quot;./components/Booklist&quot;;

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist language={languages[0]} /&gt;
      &lt;Booklist /&gt;
    &lt;/&gt;
  );
};
export default App;

</code></pre>
<p>ここでは，「<code>App</code>コンポーネントから<code>Booklist</code>コンポーネントに」「<code>language</code>という名前で」「<code>languages[0]</code>の値」を渡している．</p>
<p>タグ内に変数を入れるときは<code>{}</code>を使用する．</p>
<h2 id="propsでデータを受け取る"><a class="header" href="#propsでデータを受け取る"><code>props</code>でデータを受け取る</a></h2>
<p>続いて，値を渡される<code>Booklist.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// Booklist.jsx
import React from &quot;react&quot;;

export const Booklist = ({ language }) =&gt; {
  return (
    &lt;&gt;
      &lt;p&gt;this is {language} list component&lt;/p&gt;
    &lt;/&gt;
  );
};

</code></pre>
<p>ブラウザで画面を確認すると以下のような状態になる．</p>
<p>1つめのコンポーネントは<code>React</code>の文字列が追加されているが，2つめのコンポーネントには追加されていない．なぜだろうか．</p>
<p><img src="day01/./img/mainview04.png" alt="メイン画面4" /></p>
<p>1つめのコンポーネントには<code>App.jsx</code>で<code>language={languages[0]}</code>が記述されているが，2つめでは記述されていない．そのため，2つめのコンポーネントでは<code>props</code>が空の状態となっており表示が追加されない．</p>
<h2 id="追加"><a class="header" href="#追加">追加！</a></h2>
<p>2つめのコンポーネントにもデータを渡すには次のように<code>App.jsx</code>を編集する．</p>
<p>（ついでにコンポーネントを追加！）</p>
<pre><code class="language-jsx">// App.jsx
import React from &quot;react&quot;;
import { Booklist } from &quot;./components/Booklist&quot;;

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist language={languages[0]} /&gt;
      &lt;Booklist language={languages[1]} /&gt;
      &lt;Booklist language={languages[2]} /&gt;
    &lt;/&gt;
  );
};
export default App;

</code></pre>
<p>こうなる！</p>
<p><img src="day01/./img/mainview05.png" alt="メイン画面5" /></p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>このように，関数コンポーネントは<code>props</code>を受け取り，要素を返す関数となる．実装するときは「何を入力して」「何を出力するのか」を意識すると（多分）混乱せずすすめることができる．</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="router機能"><a class="header" href="#router機能">router機能</a></h1>
<p>実際の web アプリケーションでは，処理ごとにページを分けて行いたい場合が多い．</p>
<p>ここまでの実装では，1 つのページに全てのコンポーネントを表示していたが，本項ではコンポーネントを別ページで表現する．そのままの記述ではページ遷移が行えないので，新しく<code>react-router</code>のライブラリをインストールする．</p>
<h2 id="react-routerのインストール"><a class="header" href="#react-routerのインストール"><code>react-router</code>のインストール</a></h2>
<p>ターミナルで<strong>作業ディレクトリにいることを確認</strong>し，下記コマンドを実行する．</p>
<pre><code class="language-bash">$ npm install react-router-dom
</code></pre>
<blockquote>
<p>【解説】ルーティング</p>
<ul>
<li>通常，React で web アプリケーションを実装すると，コンポーネントが切り替わっても URL は変化しない．</li>
<li>この 2 つを関連づけて，URL からアプリ内の特定のコンポーネントにアクセスできるようにしたり，逆にアプリ内での状態変化を URL に反映させたりすることをルーティングと呼ぶ．</li>
<li>ルーティングしておくと，ブラウザの戻るボタンで戻ったり，URL を打って特定のページに直接アクセスできたりするのでいい感じになる．</li>
</ul>
</blockquote>
<h2 id="ルーティングの定義"><a class="header" href="#ルーティングの定義">ルーティングの定義</a></h2>
<p><code>react-router</code>の機能を用いてルーティングを実装する．</p>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx
import React from 'react';
import Booklist from './components/Booklist';
import { BrowserRouter, Route, Link } from 'react-router-dom';  // 追加

const App = () =&gt; {
  const languages = ['React', 'Vue', 'Angular'];
  return (
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Route exact path='/' component={Booklist} /&gt;
      &lt;Route path='/vue' component={Booklist} /&gt;
      &lt;Route path='/angular' component={Booklist} /&gt;
    &lt;/BrowserRouter&gt;
  );
}
export default App;
</code></pre>
<ul>
<li><code>&lt;BrowserRouter&gt;</code>の中に<code>&lt;Route&gt;</code>を置き，<code>path</code>に対応させたい URL を，<code>component</code>に描画したいコンポーネントを渡す．</li>
<li><code>exact</code>を設定しないと<code>path</code>が入力した URL に前方一致していれば描画されるため（全部<code>/</code>で認識されてしまう），<code>path='/'</code>には<code>exact</code>を設定している．</li>
<li>この時点では，各コンポーネントに<code>props</code>を渡していないため，URL を変更しても表示は変化しない．</li>
</ul>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>router機能を使用したい場合は，コンポーネントを必ず<code>&lt;BrowserRouter&gt;</code>内に配置すること．</p>
</blockquote>
<h2 id="ルーティングしながら-props-を渡す"><a class="header" href="#ルーティングしながら-props-を渡す">ルーティングしながら props を渡す</a></h2>
<ul>
<li>せっかく<code>props</code>でデータを渡していたので，ルーティング使用時も<code>props</code>を活用したい．</li>
<li>しかし，<code> component={Booklist}</code>のように記述すると props を記述する場所がない．</li>
<li><code>render</code>を使用すると<code>props</code>を使用できる．</li>
</ul>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx
import React from &quot;react&quot;;
import { Booklist } from &quot;./components/Booklist&quot;;
import { BrowserRouter, Route, Link } from 'react-router-dom';

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Route
        exact
        path=&quot;/&quot;
        render={(props) =&gt; &lt;Booklist language={languages[0]} /&gt;}
      /&gt;
      &lt;Route
        path=&quot;/vue&quot;
        render={(props) =&gt; &lt;Booklist language={languages[1]} /&gt;}
      /&gt;
      &lt;Route
        path=&quot;/angular&quot;
        render={(props) =&gt; &lt;Booklist language={languages[2]} /&gt;}
      /&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;

</code></pre>
<p>こうするとルーティングと<code>props</code>を併用できる．</p>
<p>ブラウザで<code>localhost:3000/vue</code>などと URL を入力して表示を確認しよう．</p>
<p><img src="day01/./img/mainview06.png" alt="メイン画面6" /></p>
<h2 id="リンクを貼る"><a class="header" href="#リンクを貼る">リンクを貼る</a></h2>
<ul>
<li>毎回 URL 入力はダルい．</li>
<li>せっかくルーティングを実装したので，リンクを張ってブラウザ上で移動できるようにしたい．</li>
<li><code>react-router</code>の<code>Link</code>機能を使うと簡単にリンクを作成できる．</li>
</ul>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx
import React from &quot;react&quot;;
import { Booklist } from &quot;./components/Booklist&quot;;
import { BrowserRouter, Route, Link } from 'react-router-dom';

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/&quot;&gt;React&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/vue&quot;&gt;Vue&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/angular&quot;&gt;Angular&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;hr /&gt;
      &lt;Route
        exact
        path=&quot;/&quot;
        render={(props) =&gt; &lt;Booklist language={languages[0]} /&gt;}
      /&gt;
      &lt;Route
        path=&quot;/vue&quot;
        render={(props) =&gt; &lt;Booklist language={languages[1]} /&gt;}
      /&gt;
      &lt;Route
        path=&quot;/angular&quot;
        render={(props) =&gt; &lt;Booklist language={languages[2]} /&gt;}
      /&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;

</code></pre>
<p><code>&lt;Link&gt;</code>タグの<code>to</code>部分に移動したい URL を書いておくと，<code>&lt;a&gt;</code>タグのようにリンクしてくれる．</p>
<p>ブラウザ画面で移動できることを確認しよう．</p>
<p><img src="day01/./img/mainview07.png" alt="メイン画面7" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="子コンポーネントへの関数入力"><a class="header" href="#子コンポーネントへの関数入力">子コンポーネントへの関数入力</a></h1>
<p>ページごとにコンポーネントを表示できたので，それぞれのページでキーワードから本のデータを取得したい．</p>
<p>子コンポーネントで関数を定義してもよいが，今回は<code>App.jsx</code>で関数を定義して子コンポーネントに渡す（関数の渡し方の練習）．</p>
<h2 id="関数の定義をpropsの-1-つとして渡す"><a class="header" href="#関数の定義をpropsの-1-つとして渡す">関数の定義を<code>props</code>の 1 つとして渡す</a></h2>
<p><code>App.jsx</code>を以下のように編集する</p>
<pre><code class="language-jsx">// App.jsx
import React from &quot;react&quot;;
import { Booklist } from &quot;./components/Booklist&quot;;
import { BrowserRouter, Route, Link } from 'react-router-dom';

const App = () =&gt; {

  // 関数を追加
  const getDataFromAPI = (keyword) =&gt; {
    return `${keyword} books`;
  };

  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/&quot;&gt;React&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/vue&quot;&gt;Vue&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/angular&quot;&gt;Angular&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;hr /&gt;
      &lt;Route
        exact
        path=&quot;/&quot;
        render={(props) =&gt; &lt;Booklist language={languages[0]} getData={getDataFromAPI} /&gt;}
      /&gt;
      &lt;Route
        path=&quot;/vue&quot;
        render={(props) =&gt; &lt;Booklist language={languages[1]} /&gt;}
      /&gt;
      &lt;Route
        path=&quot;/angular&quot;
        render={(props) =&gt; &lt;Booklist language={languages[2]} /&gt;}
      /&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;

</code></pre>
<p>ここでは「<code>getData</code>」という名前で「keyword を入力すると<code>getDataFromApi(keyword)</code>を実行する関数」を「<code>Booklist</code>コンポーネント」に渡している．</p>
<h2 id="propsからの受け取りと関数の実行"><a class="header" href="#propsからの受け取りと関数の実行">propsからの受け取りと関数の実行</a></h2>
<p>続いて，<code>Booklist</code>コンポーネントで関数を受け取って実行する．</p>
<p>子コンポーネントで，読み込み時に渡された関数を実行してその結果を要素に反映する．</p>
<pre><code class="language-jsx">// Booklist.jsx
import React from &quot;react&quot;;

export const Booklist = ({ language, getData }) =&gt; {

  const result = getData?.(language); // `?`を使用することで，`getData`が存在する場合のみ関数を実行できる

  return (
    &lt;&gt;
      &lt;p&gt;this is {result} list component&lt;/p&gt;
    &lt;/&gt;
  );
};

</code></pre>
<p>ブラウザで確認すると「react books」のように表示がされていることがわかる．<code>Vue</code>と<code>Angular</code>の部分は関数を渡していないので表示がされない状態で OK．</p>
<p><img src="day01/./img/mainview08.png" alt="メイン画面8" /></p>
<p>ここまでうまく行ったら，<code>App.jsx</code>内の<code>&lt;Route&gt;</code>要素残り 2 つも同様に追記しよう．</p>
<pre><code class="language-jsx">// App.jsx
import React from &quot;react&quot;;
import { Booklist } from &quot;./components/Booklist&quot;;
import { BrowserRouter, Route, Link } from 'react-router-dom';

const App = () =&gt; {
  const getDataFromAPI = (keyword) =&gt; {
    return `${keyword} books`;
  };

  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/&quot;&gt;React&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/vue&quot;&gt;Vue&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/angular&quot;&gt;Angular&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;hr /&gt;
      &lt;Route
        exact
        path=&quot;/&quot;
        render={(props) =&gt; &lt;Booklist language={languages[0]} getData={getDataFromAPI} /&gt;}
      /&gt;
      &lt;Route
        path=&quot;/vue&quot;
        render={(props) =&gt; &lt;Booklist language={languages[1]} getData={getDataFromAPI} /&gt;}
      /&gt;
      &lt;Route
        path=&quot;/angular&quot;
        render={(props) =&gt; &lt;Booklist language={languages[2]} getData={getDataFromAPI} /&gt;}
      /&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;

</code></pre>
<p>ブラウザで操作し，うまくいけば OK．これで親コンポーネントで定義した関数を子コンポーネントに渡すことができた．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="httpリクエストの実装"><a class="header" href="#httpリクエストの実装">httpリクエストの実装</a></h1>
<ul>
<li>子コンポーネントに関数が渡せたが，現状では入力値に文字列を追加して出力するだけの関数である．</li>
<li>そこで，指定したキーワードで Google books API からデータを取得する処理に変更する．</li>
<li>http リクエストには<code>axios</code>を使用する．</li>
</ul>
<h2 id="axiosライブラリのインストール"><a class="header" href="#axiosライブラリのインストール">axiosライブラリのインストール</a></h2>
<p>下記コマンドでインストール．</p>
<pre><code class="language-bash">$ npm install axios
</code></pre>
<p>エラーがでなければ OK．</p>
<h2 id="リクエスト関数を実装"><a class="header" href="#リクエスト関数を実装">リクエスト関数を実装</a></h2>
<p><code>App.jsx</code>の<code>getDataFromAPI</code>関数を編集する．</p>
<pre><code class="language-jsx">// App.jsx
import axios from 'axios';	// 追加

// ...省略

// 関数の内容を編集
const getDataFromAPI = async (keyword) =&gt; {
  const requestUrl = 'https://www.googleapis.com/books/v1/volumes?q=intitle:'
  const result = await axios.get(`${requestUrl}${keyword}`);
  return result;
}

// ...省略

</code></pre>
<p>※この記述だけでは動きません！！</p>
<h2 id="コンポーネントで関数を実行するusestate-useeffect"><a class="header" href="#コンポーネントで関数を実行するusestate-useeffect">コンポーネントで関数を実行する（useState, useEffect）</a></h2>
<p>子コンポーネントで<code>getDataFromAPI</code>関数を実行したいが，以下 2 つの問題がある．</p>
<ul>
<li>子コンポーネントは関数であるため，取得したデータを保持できない．</li>
<li>データ更新時にレンダリングが再実行されるため，API リクエストが無限ループになる．</li>
</ul>
<p>前者の問題には<code>useState</code>，後者の問題には<code>useEffect</code>という機能を使うことで対処できる．</p>
<p>（<code>useState</code>と<code>useEffect</code>は React の標準の機能なのでインストールなどの作業は必要ない）</p>
<p><code>Booklist.jsx</code>を下記のように編集する．</p>
<pre><code class="language-jsx">// Booklist.jsx
import React, { useState, useEffect } from &quot;react&quot;; // 追加

export const Booklist = ({ language, getData }) =&gt; {

  const [bookData, setBookData] = useState(null); // ここから追加

  useEffect(() =&gt; {
    const result = getData?.(language)
      .then((response) =&gt; setBookData(response));
  }, [language, getData]);

  // ここまで追加

  return (
    &lt;&gt;
      &lt;p&gt;this is {JSON.stringify(bookData)} list component&lt;/p&gt;
    &lt;/&gt;
  );
};

</code></pre>
<p>ブラウザで確認すると，以下のように取得したデータが文字列で表示される．</p>
<p><img src="day01/./img/mainview09.png" alt="メイン画面9" /></p>
<h2 id="解説usestate"><a class="header" href="#解説usestate">【解説】useState</a></h2>
<ul>
<li>useState は関数コンポーネントが値（今回は API から取得したデータ）を保持するための機能．</li>
<li><code>const [bookData, setBookData] = useState(null);</code>の<code>bookData</code>がデータを保持するための変数名，<code>setBookData</code>がデータを更新するための関数，<code>useState(null)</code>の<code>null</code>が<code>bookData</code>の初期値となる．</li>
<li><code>setBookData(最新の値)</code>のように記述することで，<code>bookData</code>の値が最新の値に更新される．</li>
<li><code>bookData</code>に保存した内容を表示したいときなどは通常の変数のように扱えば OK．</li>
</ul>
<h2 id="解説useeffect"><a class="header" href="#解説useeffect">【解説】useEffect</a></h2>
<ul>
<li>関数外の副作用（外部からのデータ取得や DOM の更新など）を扱うための機能．</li>
<li>React では，コンポーネント内でデータの更新があると再レンダリングされるため，API からデータを取得すると毎回レンダリングが発生して無限ループとなってしまう．</li>
<li>useEffect はレンダリングを制限し，特定の値が更新されたときのみ処理が実行されるようにしてくれる機能．</li>
<li>書式は以下のような感じ．</li>
</ul>
<pre><code class="language-jsx">useEffect(() =&gt; {
  実行したい処理
}, [ここに書いた値（今回は`language`と`getData`）が更新されたときのみ，上の{}内が実行される．ここに値を書くときは配列で書く]);
</code></pre>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p><code>useState</code>と<code>useEffect</code>以外にもhooksには便利な機能が存在する．</p>
<p>まずはこの2つを使うことで多くの処理を実装可能であるため，まずはこの2つを扱えるようになろう．</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="表示の調整"><a class="header" href="#表示の調整">表示の調整</a></h1>
<p>現状では取得したデータを全て文字列で表示しているだけなので，書籍のタイトルがリスト表示されるよう整える．</p>
<p>booksData から必要なデータを取り出して<code>map()</code>関数で<code>&lt;li&gt;</code>タグをつくる．</p>
<pre><code class="language-jsx">// Booklist.jsx
import React, { useState, useEffect } from &quot;react&quot;;

export const Booklist = ({ language, getData }) =&gt; {

  const [bookData, setBookData] = useState(null);

  useEffect(() =&gt; {
    const result = getData?.(language)
      .then((response) =&gt; setBookData(response));
  }, [language, getData]);

  return (
    &lt;ul&gt;
      {bookData.data.items.map((x) =&gt; (
        &lt;li&gt;{x.volumeInfo.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};

</code></pre>
<p>ブラウザで表示を確認するとエラーになる．</p>
<p><img src="day01/./img/mainview10.png" alt="メイン画面10" /></p>
<p>このエラーの原因は，まだ API からデータを取得していない状態でレンダリングしようとして<code>map()</code>関数が実行されているためである．<code>map()</code>関数は配列に対して処理を行う関数だが，配列のデータが存在しない状態で実行しようとしているためエラーとなる．</p>
<p>三項演算子を使用して，<code>bookData</code>の有無で表示を切り替えることで回避できる．</p>
<ul>
<li><code>bookData</code>が<code>null</code>の場合はローディング中のメッセージを表示．</li>
<li>データが取得できたらリスト表示に切り替え．</li>
</ul>
<pre><code class="language-jsx">// Booklist.jsx
import React, { useState, useEffect } from &quot;react&quot;;

export const Booklist = ({ language, getData }) =&gt; {
  const [bookData, setBookData] = useState(null);
  useEffect(() =&gt; {
    const result = getData?.(language)
      .then((response) =&gt; setBookData(response));
  }, [language, getData]);
  return (
    &lt;ul&gt;
      {
        bookData === null
          ? &lt;p&gt;now loading...&lt;/p&gt;
          : bookData.data.items.map((x, index) =&gt; (&lt;li key={index}&gt;{x.volumeInfo.title}&lt;/li&gt;))
      }
    &lt;/ul&gt;
  );
};

</code></pre>
<p>このように表示されれば OK！</p>
<p><img src="day01/./img/mainview11.png" alt="メイン画面11" /></p>
<p>リンククリックするとリストも切り替わる挙動になっている（はず）．</p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>このように，Reactではデータの取得とレンダリングのタイミングなどでハマることが多い．</p>
<p>まずはエラーをよく読むことと，目的のデータが存在しているかどうか，どんな形のデータになっているのかを確認しながら進めると良い．</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="課題任意"><a class="header" href="#課題任意">課題（任意）</a></h1>
<ul>
<li>本のタイトル以外のデータ（著者や画像）の表示．</li>
<li>別の API を使用してデータをブラウザに表示．</li>
</ul>
<p>今回はここまで( `･ω･)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="day02"><a class="header" href="#day02">Day02</a></h1>
<h2 id="今回のゴール-1"><a class="header" href="#今回のゴール-1">今回のゴール</a></h2>
<ul>
<li>Node.js と Express で簡単な API を体験する．</li>
<li>実装のしかたを複数学び，見通しの良いコードの構造を把握する．</li>
<li>サーバで動作する「おみくじ」と「じゃんけん」を実装する．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-とは"><a class="header" href="#nodejs-とは">Node.js とは</a></h1>
<p>サーバで JavaScript を動かす環境のこと．
「Node.js」という言語があるわけではないので認識違いに注意．</p>
<h2 id="web-アプリケーションの仕組みapi-を実装する場合"><a class="header" href="#web-アプリケーションの仕組みapi-を実装する場合">Web アプリケーションの仕組み（API を実装する場合）</a></h2>
<p>基本は「リクエスト」と「レスポンス」．PHP など他の言語と同じ．</p>
<p>サーバ側でリクエストを受ける URI（Uniform Resource Identifier の略．URL とほぼ同義）を用意しておき，そこにクライアント（ブラウザなど）からリクエストを送信する．</p>
<p>リクエストを受けると記述されたコードが実行され，データなどが返される（JSON 形式が多い）．</p>
<h2 id="express"><a class="header" href="#express">Express</a></h2>
<p>Express は Node.js を用いて Web アプリケーションを構築するためのフレームワーク．</p>
<p>Node.js は自由度が非常に高く，そのまま書くと人によって千差万別となる．したがって，Web 開発をするときは Express を使用するのがデファクトスタンダードとなっている状態である（他にもフレームワークは存在するが，Express を基にしたものが多い）．</p>
<p>Express は構造が簡易であり，API の実装も非常に簡単である．今回は Express を使っていくつかの API を実装してみる．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api-実装の準備"><a class="header" href="#api-実装の準備">API 実装の準備</a></h1>
<p>Node.js のプロジェクトを実装し，動かしてみる．</p>
<h2 id="プロジェクト作成"><a class="header" href="#プロジェクト作成">プロジェクト作成</a></h2>
<p>プロジェクトを作成するには，下記のコマンドを実行する．</p>
<pre><code class="language-bash">$ mkdir express-project &amp;&amp; cd express-project
$ npm init
</code></pre>
<p><code>npm</code>は<code>node package module</code>の略であり，Node.js 上で動くパッケージを管理するツールである．Node.js で開発を行う場合はこれを用いることがほとんどである．</p>
<p>ダイアログが出てくるので，答えていく．全部そのまま Enter で OK．</p>
<pre><code class="language-bash">This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt;` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (express-project)
version: (1.0.0)
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to /home/taroosg/Desktop/express-project/package.json:

{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}


Is this OK? (yes)

</code></pre>
<p>完了したらエディタで開く．</p>
<p>エディタで開いたら<code>package.json</code>が作成されているので，中身を確認する．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}

</code></pre>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>name</td><td>プロダクト名．</td></tr>
<tr><td>version</td><td>プロダクトのバージョン．</td></tr>
<tr><td>description</td><td>プロダクトの説明．</td></tr>
<tr><td>main</td><td>プロダクトをパッケージとして公開する場合に入り口となるファイルを指定する．</td></tr>
<tr><td>script</td><td>開発者が任意に作成するコマンド．</td></tr>
<tr><td>auther</td><td>開発者情報．1 人のみ記述する．</td></tr>
<tr><td>license</td><td>ライセンス情報．</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="expressのインストール"><a class="header" href="#expressのインストール">Expressのインストール</a></h1>
<p>今回は Express のフレームワークを使用するため，下記コマンドで</p>
<pre><code class="language-bash">$ npm i express
</code></pre>
<p>実行結果</p>
<pre><code class="language-bash">+ express@4.17.1
added 50 packages from 37 contributors and audited 50 packages in 1.687s
found 0 vulnerabilities

</code></pre>
<p>完了したら，再度<code>package.json</code>を開き，以下の内容が追加されていることを確認する．</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
  &quot;express&quot;: &quot;^4.17.1&quot;
}

</code></pre>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>dependencies</td><td>このプロダクトが依存するパッケージの一覧．</td></tr>
</tbody></table>
<p><code>dependencies</code>の中にインストールしたパッケージが追加される仕組み．パッケージとはいろいろな機能をまとめてインストールできるようにしたものであり，様々なものが公開されている．ライブラリとほぼ同義．</p>
<p>また，インストールされたパッケージは同時に作成される<code>node_modules</code>ディレクトリ内に保存される．このディレクトリはパッケージ専用なので，自分で触ることは殆ど無い．</p>
<p><code>package-lock.json</code>には実際にインストールしたパッケージのバージョンが記載される．基本的に触らない．</p>
<p><code>package.json</code>にはプロダクトに必要なパッケージがすべて記載される．コマンド<code>npm install</code>を実行すると，ここに記載されたパッケージがすべてインストールされる．</p>
<h2 id="gitignoreファイルの作成"><a class="header" href="#gitignoreファイルの作成"><code>.gitignore</code>ファイルの作成</a></h2>
<p>ソースコードを Git で管理することは周知のことであるが，プロジェクト内には Git で管理したくないファイルやディレクトリも存在する．</p>
<p>例えば，上記で作成された<code>node_modules</code>ディレクトリにはインストールしたパッケージだけでなく，「パッケージが必要としている別のパッケージ」もインストールされる．そのため，これらすべてを Git で管理するとファイル数が膨大になってしまう．</p>
<p>そのため，<code>node_modules</code>ディレクトリ（とその他 Git 管理したくないファイル）を<code>.gitignore</code>と呼ばれるファイルにリストアップすることで Git の管理外に措くことができる．</p>
<p>エディタで<code>.gitignore</code>を作成する．必ずプロジェクト直下に作成すること．</p>
<p>作成したら以下の内容を記述しよう．<code>.gitignore</code>から見た相対パスで Git 管理外にしたいファイルやディレクトリを指定している．</p>
<pre><code class="language-txt">/node_modules
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装1おみくじ初級編"><a class="header" href="#api実装1おみくじ初級編">API実装1（おみくじ初級編）</a></h1>
<h2 id="実行用ファイルの作成"><a class="header" href="#実行用ファイルの作成">実行用ファイルの作成</a></h2>
<p>実行するための<code>app.js</code>ファイルを作成する．エディタから作成すれば OK．</p>
<p>ファイルを作成したら下記の内容を記述する．</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = express();
const port = 3001;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.send(&quot;Hello Node.js!&quot;);
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<p>上記のコードは<code>app.js</code>が実行されると，<code>http://localhost:3001</code>でサーバが立ち上がることを示している．</p>
<p>また，<code>http://localhost:3001/</code>に<code>GET</code>でリクエストが来ると，<code>Hello Node.js!</code>というレスポンスを返すよう記述している．</p>
<h2 id="動作確認"><a class="header" href="#動作確認">動作確認</a></h2>
<p>上記を記述したら，ターミナルで以下のコマンドを実行し，サーバを起動する．実行する際には作業ディレクトリに移動しておくこと．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>実行結果．下記のようにサーバが立ち上がれば成功．</p>
<pre><code class="language-bash">Example app listening at http://localhost:3001
</code></pre>
<p>立ち上がったら，別のターミナルで下記コマンドを実行し，リクエストとレスポンスが適切に処理されることを確認する．</p>
<p>コマンドを実行してメッセージが返ってくれば成功．</p>
<pre><code class="language-bash">$ curl localhost:3001
Hello Node.js!
</code></pre>
<p><code>curl</code>はターミナルから http リクエストを送るコマンド．インストールされていない場合はインストールしておく．</p>
<p>サーバを終了する場合は<code>ctrl + c</code>で終了できる．</p>
<h2 id="uri-の追加"><a class="header" href="#uri-の追加">URI の追加</a></h2>
<p><code>/</code>以外にも URI と作成してみる．</p>
<p><code>app.js</code>を以下のように編集する．<code>/omikuji</code>，<code>/janken</code>の 2 つの URI を追加し，各レスポンスを JSON 形式で返すよう変更している．</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = express();
const port = 3001;

// 編集
app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

// 追加
app.get(&quot;/omikuji&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/omikuji&quot;,
    message: &quot;This is Omikuji URI!&quot;,
  });
});

// 追加
app.get(&quot;/janken&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/janken&quot;,
    message: &quot;This is Janken URI!&quot;,
  });
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="動作確認-1"><a class="header" href="#動作確認-1">動作確認</a></h2>
<p>記述したら，再度下記コマンドでサーバを立ち上げる．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>別のターミナルから，<code>curl</code>コマンドで動作を確認する．</p>
<pre><code class="language-bash">$ curl localhost:3001/
{&quot;uri&quot;:&quot;/&quot;,&quot;message&quot;:&quot;Hello Node.js!&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;This is Omikuji URI!&quot;}

$ curl localhost:3001/janken
{&quot;uri&quot;:&quot;/janken&quot;,&quot;message&quot;:&quot;This is Janken URI!&quot;}

</code></pre>
<p>簡単であるがこれだけで API を実装することができた．</p>
<h2 id="演習おみくじ処理の追加"><a class="header" href="#演習おみくじ処理の追加">【演習】おみくじ処理の追加</a></h2>
<p>実際におみくじの処理を追加してみよう．</p>
<p><code>app.js</code>の以下の部分におみくじの処理を書いて動作を確認しよう．サーバを起動し，以下のような結果になるように実装する．何回か実行して異なる結果が返ってくれば OK！</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;大吉&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;凶&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;中吉&quot;}

</code></pre>
<p>実装例：</p>
<pre><code class="language-js">// 省略
app.get(&quot;/omikuji&quot;, (req, res) =&gt; {
  const omikuji = [&quot;大吉&quot;, &quot;中吉&quot;, &quot;小吉&quot;, &quot;凶&quot;, &quot;大凶&quot;];
  const min = 0;
  const max = omikuji.length - 1;
  const index = Math.floor(Math.random() * (max - min + 1)) + min;
  res.json({
    uri: &quot;/omikuji&quot;,
    message: omikuji[index],
  });
});
// 省略

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="コマンドの追加"><a class="header" href="#コマンドの追加">コマンドの追加</a></h1>
<p>ここまで，下記コマンドでサーバを実行していた．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>これとは別に，プロジェクトに対して自分でコマンドを作成することができる．</p>
<p>コマンドを追加する場合は<code>package.json</code>に記述する．下記の内容を追記してみよう．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;__comment&quot;: &quot;↓ここを追記（この行は書かなくてOK）&quot;,
    &quot;start&quot;: &quot;node app.js&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;^4.17.1&quot;
  }
}
</code></pre>
<p>このように記述すると，<code>npm start</code>というコマンドを実行すると<code>node app.js</code>が実行される．</p>
<p>プロジェクトが複雑になると，場面に応じて様々なコマンドを実行したい場合がある．そのようなときに，統一されたコマンドを準備しておくことで開発をスムーズに進めることができる．</p>
<p>下記を実行するとサーバが立ち上がる．これまでと同じ動作であることを確認しよう．</p>
<pre><code class="language-bash">$ npm start
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装2おみくじ中級編"><a class="header" href="#api実装2おみくじ中級編">API実装2（おみくじ中級編）</a></h1>
<p>簡単な API を実装するだけならば，ここまでの内容で十分である．おみくじの処理部分に適当な記述をすれば問題ないであろう．</p>
<p>しかし，コードの記述量が増えてくると，見通しが悪くなってしまい，保守管理にも支障をきたす．</p>
<p>そこで，処理中の役割毎に別ファイルに記述できるようにディレクトリ構成を変更する（責務の分離，などと呼ばれる）．</p>
<h2 id="ディレクトリ構造と役割"><a class="header" href="#ディレクトリ構造と役割">ディレクトリ構造と役割</a></h2>
<p>大きく<code>routes</code>，<code>controllers</code>，<code>services</code>の 3 つに分離する．DB などと組み合わせてデータを扱う場合は他に<code>model</code>を用意するが今回は省略する．</p>
<p>各要素の役割は以下の通り．</p>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>routes</td><td>URI と実行する処理の対応．</td></tr>
<tr><td>controllers</td><td>リクエストパラメータの検証，レスポンス送信．</td></tr>
<tr><td>services</td><td>リクエストに対する処理のメインロジック．DB 扱う場合はここに CRUD 処理など記述．</td></tr>
</tbody></table>
<p>このような役割分担とするため，以下のようにディレクトリとファイルを作成する．</p>
<pre><code class="language-bash">.
├── app.js
├── controllers
│   └── omikuji.controller.js
├── node_modules
├── package.json
├── package-lock.json
├── routes
│   └── omikuji.route.js
└── services
    └── omikuji.service.js

</code></pre>
<h2 id="実行ファイルの実装"><a class="header" href="#実行ファイルの実装">実行ファイルの実装</a></h2>
<p><code>app.js</code>を以下のように編集する．</p>
<p>ルーティングは routes 以下のファイルに任せ，指定したファイルを読み込むよう記述．</p>
<pre><code class="language-js">// app.js
const express = require(&quot;express&quot;);
const app = express();
const port = 3001;
// おみくじのrouterを読み込む
const omikujiRouter = require(&quot;./routes/omikuji.route&quot;);

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

// おみくじのルーティングを変更
app.use(&quot;/omikuji&quot;, (req, res) =&gt; omikujiRouter(req, res));

app.get(&quot;/janken&quot;, (req, res) =&gt; {
  res.json({ message: &quot;This is Janken URI!&quot; });
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="ルーティングの実装"><a class="header" href="#ルーティングの実装">ルーティングの実装</a></h2>
<p><code>routes/omikuji.route.js</code>に以下の内容を記述する．</p>
<p>URI と対応するコントローラの処理を記述する．</p>
<pre><code class="language-js">// routes/omikuji.route.js
const express = require(&quot;express&quot;);
const router = express.Router();

const OmikujiController = require(&quot;../controllers/omikuji.controller&quot;);

router.get(&quot;/&quot;, (req, res) =&gt; OmikujiController.getResult(req, res));

module.exports = router;

</code></pre>
<h2 id="コントローラの実装"><a class="header" href="#コントローラの実装">コントローラの実装</a></h2>
<p><code>controllers/omikuji.controller.js</code>に以下の内容を記述する．</p>
<p>サービスを呼び出して実行したいメソッドを指定し，結果によってレスポンスを指定する．</p>
<pre><code class="language-js">// controllers/omikuji.controller.js
const OmikujiService = require(&quot;../services/omikuji.service&quot;);

exports.getResult = async (req, res, next) =&gt; {
  try {
    const result = await OmikujiService.getOmikuji({});
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully get Omikuji!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの実装"><a class="header" href="#サービスの実装">サービスの実装</a></h2>
<p><code>services/omikuji.service.js</code>に以下の内容を記述する．</p>
<p>サービスでは実行したいロジックを書く．ここでおみくじのロジックを実装している．</p>
<pre><code class="language-js">// services/omikuji.service.js
exports.getOmikuji = async (query) =&gt; {
  try {
    const omikuji = [&quot;大吉&quot;, &quot;中吉&quot;, &quot;小吉&quot;, &quot;凶&quot;, &quot;大凶&quot;];
    const min = 0;
    const max = omikuji.length - 1;
    const index = Math.floor(Math.random() * (max - min + 1)) + min;
    return { result: omikuji[index] };
  } catch (e) {
    throw Error(&quot;Error while getting Omikuji.&quot;);
  }
};

</code></pre>
<p>処理の順序としては以下のようになる．</p>
<pre><code class="language-txt">リクエスト               レスポンス
   ↓                       ↑
routes/omikuji.route.js    |
   ↓                       |
controllers/omikuji.controller.js
   ↓           ↑
ervices/omikuji.service.js

</code></pre>
<h2 id="動作確認-2"><a class="header" href="#動作確認-2">動作確認</a></h2>
<p>サーバを立ち上げ，以下のコマンドでリクエストを送信する．</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
</code></pre>
<p>おみくじの結果が返ってくれば成功．数回実行し，異なる結果が返ってくることを確認しておこう．</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;凶&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;大凶&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;中吉&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;大吉&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

</code></pre>
<p>ユーザに返すレスポンスを変更したい場合はコントローラを，処理の内容を更新したい場合はサービスを書き換えれば良い．このように，各責務を別の場所に置くことでメンテナンスしやすいプロダクトになる．</p>
<p>これでおみくじの実装は完了である．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装3じゃんけん"><a class="header" href="#api実装3じゃんけん">API実装3（じゃんけん）</a></h1>
<p>おみくじの実装ができたので，ユーザ側からデータを送信してじゃんけんの結果を返す API を実装してみる．</p>
<h2 id="アプリケーションの全体像"><a class="header" href="#アプリケーションの全体像">アプリケーションの全体像</a></h2>
<p>ユーザはリクエスト時に<code>post</code>メソッドで自分の手を送信する．サーバ側はユーザから送信された手に対してランダムで手を出し，「ユーザの手」「サーバの手」「勝敗」をレスポンスで返却する．</p>
<p>下図を参考に，必要なファイルを作成する．</p>
<pre><code class="language-bash">.
├── app.js
├── controllers
│   ├── janken.controller.js
│   └── omikuji.controller.js
├── node_modules
├── package.json
├── package-lock.json
├── routes
│   ├── janken.route.js
│   └── omikuji.route.js
└── services
    ├── janken.service.js
    └── omikuji.service.js

</code></pre>
<h2 id="各ファイルの実装"><a class="header" href="#各ファイルの実装">各ファイルの実装</a></h2>
<p><code>app.js</code>を以下のように編集する．</p>
<p>じゃんけんのルーティングを読み込む．また，POST メソッドでデータを受け取るためには<code>body-parser</code>が必要になるため読み込んでいる．</p>
<pre><code class="language-js">// app.js
const express = require(&quot;express&quot;);
const app = express();
// ↓POSTでデータを受け取るために必要
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
const port = 3001;

const omikujiRouter = require(&quot;./routes/omikuji.route&quot;);

// じゃんけんのルーティングを読み込む
const jankenRouter = require(&quot;./routes/janken.route&quot;);

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

app.use(&quot;/omikuji&quot;, (req, res) =&gt; omikujiRouter(req, res));
// じゃんけんのルーティングを追加
app.use(&quot;/janken&quot;, (req, res) =&gt; jankenRouter(req, res));

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="ルーティングの実装-1"><a class="header" href="#ルーティングの実装-1">ルーティングの実装</a></h2>
<p><code>routes/janken.route.js</code>に以下の内容を記述する．</p>
<p>URI と対応するコントローラの処理を記述する．今回は POST で受け取る点と送信されてきたデータが<code>req</code>に入っている点に注意．</p>
<pre><code class="language-js">// routes/janken.route.js
const express = require(&quot;express&quot;);
const router = express.Router();

const JankenController = require(&quot;../controllers/janken.controller&quot;);

router.post(&quot;/&quot;, (req, res) =&gt; JankenController.getResult(req, res));

module.exports = router;

</code></pre>
<h2 id="コントローラの実装-1"><a class="header" href="#コントローラの実装-1">コントローラの実装</a></h2>
<p><code>controllers/janken.controller.js</code>に以下の内容を記述する．</p>
<p>おみくじの場合とほぼ同じ．</p>
<pre><code class="language-js">// controllers/janken.controller.js
const JankenService = require(&quot;../services/janken.service&quot;);

exports.getResult = async (req, res, next) =&gt; {
  try {
    const result = await JankenService.getJanken(req.body);
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully get Janken!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの実装-1"><a class="header" href="#サービスの実装-1">サービスの実装</a></h2>
<p><code>services/janken.service.js</code>に以下の内容を記述する．</p>
<p>とりあえず毎回同じ結果を返している．</p>
<pre><code class="language-js">// services/janken.service.js
exports.getJanken = async (query) =&gt; {
  try {
    return { yourHand: query.myhand, comHand: &quot;グー&quot;, result: &quot;テスト中&quot; };
  } catch (e) {
    throw Error(&quot;Error while getting Janken&quot;);
  }
};

</code></pre>
<h2 id="動作確認-3"><a class="header" href="#動作確認-3">動作確認</a></h2>
<p>サーバを立ち上げて，<code>curl</code>コマンドでリクエストを送信する．POST する場合は下記の書式で実行する．</p>
<p>結果が返ってくれば成功．</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;パー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;パー&quot;,&quot;comHand&quot;:&quot;グー&quot;,&quot;result&quot;:&quot;テスト中&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}
</code></pre>
<p>サーバに対して<code>{&quot;myhand&quot;:&quot;パー&quot;}</code>という JSON 形式のデータを POST メソッドで送信している．</p>
<h2 id="演習じゃんけんの実装"><a class="header" href="#演習じゃんけんの実装">【演習】じゃんけんの実装</a></h2>
<p>上記で記述した<code>services/janken.service.js</code>にじゃんけんのロジックを実装してみよう．</p>
<p>サーバを立ち上げて，以下のようにじゃんけんができれば OK！</p>
<pre><code class="language-js">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;グー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;グー&quot;,&quot;comHand&quot;:&quot;チョキ&quot;,&quot;result&quot;:&quot;Win&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;チョキ&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;チョキ&quot;,&quot;comHand&quot;:&quot;パー&quot;,&quot;result&quot;:&quot;Win&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;パー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;パー&quot;,&quot;comHand&quot;:&quot;チョキ&quot;,&quot;result&quot;:&quot;Lose&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

</code></pre>
<p>じゃんけんができたら，グーチョキパー以外の手を送信すると NG なメッセージが返す実装にもチャレンジ！</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;無敵のアレ&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;message&quot;:&quot;Invalid hand...&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

</code></pre>
<p>実装例：</p>
<pre><code class="language-js">// services/janken.service.js
exports.getJanken = async (query) =&gt; {
  try {
    const hand = [&quot;グー&quot;, &quot;チョキ&quot;, &quot;パー&quot;];
    const myIndex = hand.indexOf(query.myhand);
    if (myIndex === -1) return { message: &quot;Invalid hand...&quot; };
    const comIndex = Math.floor(Math.random() * 3);
    const resultSheet = [
      [&quot;Draw&quot;, &quot;Win&quot;, &quot;Lose&quot;],
      [&quot;Lose&quot;, &quot;Draw&quot;, &quot;Win&quot;],
      [&quot;Win&quot;, &quot;Lose&quot;, &quot;Draw&quot;],
    ];
    return {
      yourHand: query.myhand,
      comHand: hand[comIndex],
      result: resultSheet[myIndex][comIndex],
    };
  } catch (e) {
    throw Error(&quot;Error while getting Janken&quot;);
  }
};

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h1>
<p>今回は Node.js を用いて API サーバを実装してみた．</p>
<p>おみくじやじゃんけんの実装を通じて，必要な処理に含まれる責務を分離し，別々のファイルに実装した．</p>
<p>Node.js はシンプルな構成で柔軟な API を構築できる魅力的な技術である．興味を持った方は，じゃんけんの勝率変更や DB 連携などにも挑戦してみると良いだろう．</p>
<p>今回は以上である( `･ω･)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="day03"><a class="header" href="#day03">Day03</a></h1>
<h2 id="今回のゴール-2"><a class="header" href="#今回のゴール-2">今回のゴール</a></h2>
<ul>
<li>Cloud Firestore を用いたデータの永続化を実装する．</li>
<li>todo リストを実装し，CRUD 処理とデータの構造を把握する．</li>
<li>外部データ取得 -&gt; データ保存の流れを実装し，複数の処理を連携させる感覚を掴む．</li>
</ul>
<h2 id="nodejs-におけるデータ永続化"><a class="header" href="#nodejs-におけるデータ永続化">Node.js におけるデータ永続化</a></h2>
<p>データの永続化とは，アプリケーションの状態によらずデータを保持することである．言い換えると，DB などの外部にデータを保存すること．</p>
<p>データの永続化に使用する外部 DB は次のようなものがある．Node.js ではいずれの DB も利用できるが，RDB であれば MySQL か PostgreSQL，NoSQL では MongoDB，Firebase，Redis などがよく用いられる．</p>
<h3 id="rdb"><a class="header" href="#rdb">RDB</a></h3>
<p>SQL を用いてデータ管理を行う DB．柔軟な集計や結合ができ，情報も多い．基本的には同じ SQL を記述すれば同じ動作が実行されるが，それぞれの DB で仕様が異なる部分もあるので使用前は要チェック．</p>
<p>できることは非常に幅広く，データを扱う上でできないことはほぼないと考えて良い．</p>
<ul>
<li>MySQL</li>
<li>PostgreSQL</li>
<li>OracleDB</li>
</ul>
<h3 id="nosql"><a class="header" href="#nosql">NoSQL</a></h3>
<p>Not Only SQL．SQL を前提としたデータ構造に縛られない DB．「値」およびそれを取得するための「キー」だけを格納できる Key-Value 型の DB などが代表的だ．下記の例においてもそれぞれデータ構造が異なるため，プロジェクトの目的に合致した DB を選択する必要がある．</p>
<p>RDB と比較して後発のためにより直感的に扱えるものが多い一方で，データの格納および取得が高度に最適化されているが故に，機能性を最小限にしているものもある．</p>
<ul>
<li>MongoDB</li>
<li>Firebase Realtime DB</li>
<li>Firebase Cloud Firestore</li>
<li>Redis</li>
<li>DynamoDB</li>
<li>Neo4j</li>
</ul>
<h2 id="cloud-firestore-の準備"><a class="header" href="#cloud-firestore-の準備">Cloud Firestore の準備</a></h2>
<p>今回は NoSQL である Firebase Cloud Firestore を用いて CRUD 処理を実装してみる．</p>
<h3 id="db-の作成"><a class="header" href="#db-の作成">DB の作成</a></h3>
<ul>
<li>Firebase のコンソールにアクセスし，今回のプロジェクトのページを表示．</li>
<li>左側メニューの「Cloud Firestore」をクリックし，DB を作成する．必ず「テストモード」にチェックを入れて作成すること．リージョンは任意．</li>
</ul>
<h3 id="json-ファイルのダウンロード"><a class="header" href="#json-ファイルのダウンロード">JSON ファイルのダウンロード</a></h3>
<p>Node.js で CloudFirestore を操作するには，設定ファイルを用意する必要がある．Firebase で適当なプロジェクトを作成したら，下記の手順で必要なファイルをダウンロードする．</p>
<ul>
<li>Firebase のコンソールにアクセスし，今回のプロジェクトのページを表示．</li>
<li>⚙ -&gt; プロジェクトを設定 で設定画面を表示．</li>
<li>「サービスアカウント」タブ -&gt; 「サービスアカウントを作成」ボタン -&gt; 「新しい秘密鍵の作成」ボタン -&gt; 「キーの生成」ボタンの順にクリック．</li>
<li>適当な場所に json ファイルを保存する．</li>
<li>コンソール画面は開いたままにしておこう．</li>
</ul>
<h3 id="json-ファイルの配置と構成ファイルの作成"><a class="header" href="#json-ファイルの配置と構成ファイルの作成">JSON ファイルの配置と構成ファイルの作成</a></h3>
<ul>
<li>
<p>プロジェクト直下に<code>model</code>ディレクトリを作成する．<code>model</code>ディレクトリの中に ↑ でダウンロードした json ファイルを移動する．</p>
</li>
<li>
<p><code>model</code>ディレクトリの中に<code>firebase.js</code>ファイルを作成する．</p>
</li>
<li>
<p><code>firebase.js</code>ファイルに ↑ で開いたコンソール画面から Admin SDK 構成スニペットをコピペする．</p>
</li>
<li>
<p><code>var serviceAccount = require(&quot;...&quot;);</code>の部分の<code>require()</code>内を json ファイルのパスに書き換える．</p>
</li>
<li>
<p>最下行に<code>module.exports = admin;</code>を追記する．</p>
</li>
</ul>
<p><code>firebase.js</code>は以下のような状態．</p>
<pre><code class="language-js">var admin = require(&quot;firebase-admin&quot;);

var serviceAccount = require(&quot;./hogehoge-22c0e-firebase-adminsdk-hhdd7-1234567890.json&quot;);

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});
module.exports = admin;

</code></pre>
<h3 id="gitignoreに追記"><a class="header" href="#gitignoreに追記"><code>.gitignore</code>に追記</a></h3>
<p>下記を追記しておく．ダウンロードした JSON ファイルには Firebase プロジェクトの情報が含まれているためである．</p>
<p>サーバにデプロイする場合にも必要になるため，その場合は環境変数などを使用して工夫する必要がある．</p>
<pre><code>/node_modules
/model/hogehoge-22c0e-firebase-adminsdk-hhdd7-1234567890.json
</code></pre>
<h3 id="必要なパッケージのインストール"><a class="header" href="#必要なパッケージのインストール">必要なパッケージのインストール</a></h3>
<p>下記コマンドでインストールする．必ずプロジェクトのディレクトリで行うこと．</p>
<pre><code class="language-bash">$ npm i firebase-admin

+ firebase-admin@9.5.0
added 120 packages from 109 contributors and audited 230 packages in 21.873s
</code></pre>
<h2 id="既存ファイルへの追記と新規ファイルの準備"><a class="header" href="#既存ファイルへの追記と新規ファイルの準備">既存ファイルへの追記と新規ファイルの準備</a></h2>
<p><code>app.js</code>にルーティングを追記する．</p>
<pre><code class="language-js">const express = require(&quot;express&quot;);
const app = express();

app.use(express.urlencoded({ extended: true }));
app.use(express.json());

const port = 3001;
const omikujiRouter = require(&quot;./routes/omikuji.route&quot;);
const jankenRouter = require(&quot;./routes/janken.route&quot;);
// ↓追加
const todoRouter = require(&quot;./routes/todo.route&quot;);

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

app.use(&quot;/omikuji&quot;, (req, res) =&gt; omikujiRouter(req, res));
app.use(&quot;/janken&quot;, (req, res) =&gt; jankenRouter(req, res));
// ↓追加
app.use(&quot;/todo&quot;, (req, res) =&gt; todoRouter(req, res));

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<p>新しく以下のファイルを作成する．</p>
<ul>
<li><code>routes/todo.route.js</code></li>
<li><code>controllers/todo.controller.js</code></li>
<li><code>services/todo.service.js</code></li>
</ul>
<p>作成したら以下の内容を記述する．</p>
<p>まずはルーティングを作成．</p>
<pre><code class="language-js">// routes/todo.route.js
const express = require(&quot;express&quot;);
const router = express.Router();

const TodoController = require(&quot;../controllers/todo.controller&quot;);

router.get(&quot;/&quot;, (req, res) =&gt; TodoController.readTodoData(req, res));

module.exports = router;

</code></pre>
<p>コントローラではリクエストとレスポンスを定義．</p>
<pre><code class="language-js">// controllers/todo.controller.js
const TodoService = require(&quot;../services/todo.service&quot;);

exports.readTodoData = async (req, res, next) =&gt; {
  try {
    const result = await TodoService.readTodoData();
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully get Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<p>サービスでは一旦決まったメッセージを返す．</p>
<pre><code class="language-js">// services/todo.service.js
exports.readTodoData = async () =&gt; {
  try {
    return { message: &quot;OK&quot; };
  } catch (e) {
    throw Error(&quot;Error while getting Todo Data&quot;);
  }
};

</code></pre>
<p>動作確認する．以下のコマンドでレスポンスが返ってくれば OK．</p>
<pre><code class="language-bash">$ curl localhost:3001/todo

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;message&quot;: &quot;OK&quot;
  },
  &quot;message&quot;: &quot;Succesfully get Todo Data!&quot;
}

</code></pre>
<h2 id="crud-処理の作成"><a class="header" href="#crud-処理の作成">CRUD 処理の作成</a></h2>
<p>一通りの動作が確認できたら，Firestore の CRUD 処理を作成していく．</p>
<h3 id="create-の処理"><a class="header" href="#create-の処理">Create の処理</a></h3>
<p>今回は<code>POST</code>メソッドでデータを送信し，新規レコードを作成する．</p>
<p>ルーティングでは，collection 名とデータを受け取り，コントローラにデータを渡す．</p>
<pre><code class="language-js">// routes/todo.route.js
const express = require(&quot;express&quot;);
const router = express.Router();

const TodoController = require(&quot;../controllers/todo.controller&quot;);

router.get(&quot;/&quot;, (req, res) =&gt; TodoController.readTodoData(req, res));
// ↓追加
router.post(&quot;/&quot;, (req, res) =&gt; TodoController.createTodoData(req, res));

module.exports = router;

</code></pre>
<p>コントローラでは，データを整理してサービスに渡す．また，サービスの処理結果を元にレスポンスを返す．</p>
<pre><code class="language-js">// controllers/todo.controller.js
const TodoService = require(&quot;../services/todo.service&quot;);

exports.readTodoData = async (req, res, next) =&gt; {
  // 省略
};

// ↓追加
exports.createTodoData = async (req, res, next) =&gt; {
  try {
    const { todo, deadline } = req.body;
    if (!(todo &amp;&amp; deadline)) {
      throw new Error(&quot;something is blank&quot;);
    }
    const result = await TodoService.createTodoData({
      data: { todo: todo, deadline: deadline },
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully post Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<p>サービスでは受け取ったデータに<code>created_at</code>など必要なデータを追加し，Firebase に送信する．本来は Firebase にデータを保存する処理は<code>repositories</code>など別レイヤーに分割することが望ましい．</p>
<p>また，Cloud Firestore では日時が独自形式なので，<code>deadline</code>を変換している．</p>
<p>collection が存在しない場合は自動的に作成される．処理が実行されると，作成された Document の ID と追加データが返される．</p>
<pre><code class="language-js">// services/todo.service.js

// ↓追加
const admin = require(&quot;../model/firebase&quot;);
const db = admin.firestore();

exports.readTodoData = async () =&gt; {
  // 省略
};

// ↓追加
exports.createTodoData = async ({ data }) =&gt; {
  try {
    const postData = {
      ...data,
      deadline: admin.firestore.Timestamp.fromDate(new Date(data.deadline)),
      done: false,
      created_at: admin.firestore.Timestamp.now(),
      updated_at: admin.firestore.Timestamp.now(),
    };
    const ref = await db.collection(&quot;todo&quot;).add(postData);
    return {
      id: ref.id,
      data: postData,
    };
  } catch (e) {
    throw Error(&quot;Error while posting Todo Data&quot;);
  }
};

</code></pre>
<p>処理を追加したら動作確認する．サーバを起動して下記コマンドでデータを送信し，成功のレスポンスが返ってくれば OK．</p>
<p>また，Firebase のコンソール画面から Cloud Firestore にアクセスし，送信したデータが保存されていることを確認しておく．</p>
<p>動作が確認できたら，2-3 件データを入れておこう．</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;todo&quot;:&quot;node.js&quot;,&quot;deadline&quot;:&quot;2021-02-17&quot;}' localhost:3001/todo

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;id&quot;: &quot;mA665PVzkTzqxxBx0Msv&quot;,
    &quot;data&quot;: {
      &quot;todo&quot;: &quot;node.js&quot;,
      &quot;deadline&quot;: {
        &quot;_seconds&quot;: 1613520000,
        &quot;_nanoseconds&quot;: 0
      },
      &quot;done&quot;: false,
      &quot;created_at&quot;: {
        &quot;_seconds&quot;: 1613117267,
        &quot;_nanoseconds&quot;: 915000000
      },
      &quot;updated_at&quot;: {
        &quot;_seconds&quot;: 1613117267,
        &quot;_nanoseconds&quot;: 915000000
      }
    }
  },
  &quot;message&quot;: &quot;Succesfully post Firestore Data!&quot;
}

</code></pre>
<h3 id="read-の処理"><a class="header" href="#read-の処理">Read の処理</a></h3>
<p>Read の処理では，ルーティングとコントローラははじめにつくったものを使用する．</p>
<p>サービスに以下の内容を記述する．collection 名を指定してデータをすべて取得する．日付部分は独自形式なので，データ取得後に<code>Date</code>形式に変換している．</p>
<p><code>todoSnapshot</code>は取得したデータそのままで使いにくいので，必要な部分を取り出して<code>todos</code>に入れている．</p>
<pre><code class="language-js">// services/todo.service.js
const admin = require(&quot;../model/firebase&quot;);
const db = admin.firestore();

// ↓編集
exports.readTodoData = async () =&gt; {
  try {
    const todoSnapshot = await db.collection(&quot;todo&quot;).get();
    const todos = todoSnapshot.docs.map((x) =&gt; {
      return {
        id: x.id,
        data: {
          ...x.data(),
          deadline: x.data().deadline.toDate(),
          created_at: x.data().created_at.toDate(),
          updated_at: x.data().updated_at.toDate(),
        },
      };
    });
    return todos;
  } catch (e) {
    throw Error(&quot;Error while getting Todo Data&quot;);
  }
};

exports.createTodoData = async ({ collection, data }) =&gt; {
  // 省略
};

</code></pre>
<p>記述したら動作確認する．下記コマンドを実行して，保存されているデータが全件取得できれば OK（下記はデータ 2 件登録時の例）．</p>
<pre><code class="language-bash">$ curl localhost:3001/todo

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: &quot;hUqyK0rwVdzGQMWGrVCh&quot;,
      &quot;data&quot;: {
        &quot;deadline&quot;: &quot;2021-02-17T00:00:00.000Z&quot;,
        &quot;done&quot;: false,
        &quot;created_at&quot;: &quot;2021-02-12T08:27:52.390Z&quot;,
        &quot;updated_at&quot;: &quot;2021-02-12T08:27:52.390Z&quot;,
        &quot;todo&quot;: &quot;node.js&quot;
      }
    },
    {
      &quot;id&quot;: &quot;jmzfkE9XLzCMJ0k6gLtD&quot;,
      &quot;data&quot;: {
        &quot;done&quot;: false,
        &quot;created_at&quot;: &quot;2021-02-12T08:27:46.442Z&quot;,
        &quot;deadline&quot;: &quot;2021-02-24T00:00:00.000Z&quot;,
        &quot;updated_at&quot;: &quot;2021-02-12T08:27:46.442Z&quot;,
        &quot;todo&quot;: &quot;next.js&quot;
      }
    }
  ],
  &quot;message&quot;: &quot;Succesfully get Todo Data!&quot;
}

</code></pre>
<h3 id="update-の処理"><a class="header" href="#update-の処理">Update の処理</a></h3>
<p>update のルーティングを追加．<code>:id</code>はユーザが付加したパラメータを指定する．コントローラで<code>req.params.id</code>で取得する．</p>
<p>例えば，<code>/hoge</code>に<code>PUT</code>でリクエストを送信した場合，<code>req.params.id</code>は<code>hoge</code>になる．</p>
<pre><code class="language-js">// routes/todo.route.js
const express = require(&quot;express&quot;);
const router = express.Router();

const TodoController = require(&quot;../controllers/todo.controller&quot;);

router.get(&quot;/&quot;, (req, res) =&gt; TodoController.readTodoData(req, res));
router.post(&quot;/&quot;, (req, res) =&gt; TodoController.createTodoData(req, res));
// ↓追加
router.put(&quot;/:id&quot;, (req, res) =&gt; TodoController.updateTodoData(req, res));

module.exports = router;

</code></pre>
<p>コントローラでは，リクエストから<code>更新対象のドキュメントのid</code>と<code>更新データ</code>の 2 つを受け取る．送信されたデータの中から，これら 2 つのデータを抽出し，サービスに渡す．</p>
<pre><code class="language-js">// controllers/todo.controller.js
const TodoService = require(&quot;../services/todo.service&quot;);

exports.readTodoData = async (req, res, next) =&gt; {
  // 省略
};

exports.createTodoData = async (req, res, next) =&gt; {
  // 省略
};

// ↓追加
exports.updateTodoData = async (req, res, next) =&gt; {
  try {
    const { id } = req.params;
    const { todo, deadline, done } = req.body;
    if (!(id &amp;&amp; todo &amp;&amp; deadline &amp;&amp; typeof done === &quot;boolean&quot;)) {
      throw new Error(&quot;something is blank&quot;);
    }
    const result = await TodoService.updateTodoData({
      id: id,
      data: { todo: todo, deadline: deadline, done: done },
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully update Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<p>サービスでは，受け取ったデータで DB を更新する．<code>deadline</code>を Firestore の形式に変換し，同時に<code>updated_at</code>に実行日時を設定して送信する．</p>
<p>collection 名と document 名を指定して<code>update()</code>でデータを更新できる．実行完了後には，更新ドキュメントの id と更新データを返す．</p>
<pre><code class="language-js">// services/todo.service.js
const admin = require(&quot;../model/firebase&quot;);
const db = admin.firestore();

exports.readTodoData = async () =&gt; {
  // 省略
};

exports.createTodoData = async ({ data }) =&gt; {
  // 省略
};

// ↓追加
exports.updateTodoData = async ({ id, data }) =&gt; {
  try {
    const updateData = {
      ...data,
      deadline: admin.firestore.Timestamp.fromDate(new Date(data.deadline)),
      updated_at: admin.firestore.Timestamp.now(),
    };
    const ref = await db.collection(&quot;todo&quot;).doc(id).update(updateData);
    return {
      id: ref.id,
      data: updateData,
    };
  } catch (e) {
    throw Error(&quot;Error while updating Todo Data&quot;);
  }
};

</code></pre>
<p>動作確認する．document は既存のデータから適当に指定する．Read の処理結果などから存在する document 名 を確認しておこう．</p>
<p>コンソール画面 or 前項の Read 処理でデータを確認し，データが更新されていれば OK！</p>
<pre><code class="language-bash">$ curl -X PUT -H &quot;Content-Type: application/json&quot; -d '{&quot;todo&quot;:&quot;nest.js&quot;,&quot;deadline&quot;:&quot;2021-02-28&quot;,&quot;done&quot;:true}' localhost:3001/todo/yQjmX9lHuRM5WxIUCAjg

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;data&quot;: {
      &quot;todo&quot;: &quot;nest.js&quot;,
      &quot;deadline&quot;: {
        &quot;_seconds&quot;: 1614470400,
        &quot;_nanoseconds&quot;: 0
      },
      &quot;done&quot;: true,
      &quot;updated_at&quot;: {
        &quot;_seconds&quot;: 1613122454,
        &quot;_nanoseconds&quot;: 165000000
      }
    }
  },
  &quot;message&quot;: &quot;Succesfully update Todo Data!&quot;
}

</code></pre>
<h3 id="delete-の処理"><a class="header" href="#delete-の処理">Delete の処理</a></h3>
<p>削除のルーティングを追加．更新の場合と同様にパラメータを受け取る．</p>
<pre><code class="language-js">// routes/todo.route.js
const express = require(&quot;express&quot;);
const router = express.Router();

const TodoController = require(&quot;../controllers/todo.controller&quot;);

router.get(&quot;/&quot;, (req, res) =&gt; TodoController.readTodoData(req, res));
router.post(&quot;/&quot;, (req, res) =&gt; TodoController.createTodoData(req, res));
router.put(&quot;/:id&quot;, (req, res) =&gt; TodoController.updateTodoData(req, res));
// ↓追加
router.delete(&quot;/:id&quot;, (req, res) =&gt; TodoController.deleteTodoData(req, res));

module.exports = router;

</code></pre>
<p>コントローラでは document 名を受け取り，collection 名と document 名を指定してサービスの処理を実行する．</p>
<pre><code class="language-js">// controllers/todo.controller.js
const TodoService = require(&quot;../services/todo.service&quot;);

exports.readTodoData = async (req, res, next) =&gt; {
  // 省略
};

exports.createTodoData = async (req, res, next) =&gt; {
  // 省略
};

exports.updateTodoData = async (req, res, next) =&gt; {
  // 省略
};

// ↓追加
exports.deleteTodoData = async (req, res, next) =&gt; {
  try {
    const { id } = req.params;
    if (!id) {
      throw new Error(&quot;something is blank&quot;);
    }
    const result = await TodoService.deleteTodoData({
      collection: &quot;todo&quot;,
      id: id,
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully delete Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<p>サービスでは DB からデータを削除する．collection 名と document 名があればデータを指定して削除することができる．</p>
<pre><code class="language-js">// services/todo.service.js
const admin = require(&quot;../model/firebase&quot;);
const db = admin.firestore();

exports.readTodoData = async () =&gt; {
  // 省略
};

exports.createTodoData = async ({ data }) =&gt; {
  // 省略
};

exports.updateTodoData = async ({ id, data }) =&gt; {
  // 省略
};

// ↓追加
exports.deleteTodoData = async ({ collection, id }) =&gt; {
  try {
    const ref = await db.collection(collection).doc(id).delete();
    return {
      id: id,
    };
  } catch (e) {
    throw Error(&quot;Error while deleting Todo Data&quot;);
  }
};

</code></pre>
<p>動作確認する．document 名 は既存のデータから適当に指定する．</p>
<p>コンソール画面 or 前項の Read 処理でデータを確認し，データが削除されていれば OK！</p>
<pre><code class="language-bash">$ curl -X DELETE localhost:3001/todo/yQjmX9lHuRM5WxIUCAjg

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;id&quot;: &quot;yQjmX9lHuRM5WxIUCAjg&quot;
  },
  &quot;message&quot;: &quot;Succesfully delete Todo Data!&quot;
}

</code></pre>
<h2 id="まとめ-1"><a class="header" href="#まとめ-1">まとめ</a></h2>
<p>今回は Node.js におけるデータの永続化を扱った．DB は Firestore を用いたが，他の DB でも処理の手順は同様である．</p>
<p>本来は DB 関連の処理は別のレイヤーに切り出すことが望ましい．そうすることで，DB 変更時にもコードの修正を該当レイヤーのみに閉じ込めることができる．</p>
<p>今回は以上である( `･ω･´)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="day04"><a class="header" href="#day04">Day04</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
