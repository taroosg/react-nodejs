<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>React-Node.js</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="day02/index.html"><strong aria-hidden="true">1.</strong> Day01</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day02/about-nodejs.html"><strong aria-hidden="true">1.1.</strong> Node.js とは</a></li><li class="chapter-item expanded "><a href="day02/prepare-api.html"><strong aria-hidden="true">1.2.</strong> API 実装の準備</a></li><li class="chapter-item expanded "><a href="day02/install-express.html"><strong aria-hidden="true">1.3.</strong> Express のインストール</a></li><li class="chapter-item expanded "><a href="day02/omikuji-api01.html"><strong aria-hidden="true">1.4.</strong> API 実装 1（おみくじ初級編）</a></li><li class="chapter-item expanded "><a href="day02/add-command.html"><strong aria-hidden="true">1.5.</strong> コマンドの追加</a></li><li class="chapter-item expanded "><a href="day02/omikuji-api02.html"><strong aria-hidden="true">1.6.</strong> API 実装 2（おみくじ中級編）</a></li><li class="chapter-item expanded "><a href="day02/janken-api.html"><strong aria-hidden="true">1.7.</strong> API 実装 3（じゃんけん）</a></li><li class="chapter-item expanded "><a href="day02/summary.html"><strong aria-hidden="true">1.8.</strong> まとめ</a></li></ol></li><li class="chapter-item expanded "><a href="day03/index.html"><strong aria-hidden="true">2.</strong> Day02</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day03/about-perpetuation.html"><strong aria-hidden="true">2.1.</strong> データの永続化について</a></li><li class="chapter-item expanded "><a href="day03/setup-firestore.html"><strong aria-hidden="true">2.2.</strong> Firestore の準備</a></li><li class="chapter-item expanded "><a href="day03/setup-files.html"><strong aria-hidden="true">2.3.</strong> ファイル作成と動作確認</a></li><li class="chapter-item expanded "><a href="day03/crud-create.html"><strong aria-hidden="true">2.4.</strong> Create の処理</a></li><li class="chapter-item expanded "><a href="day03/crud-read-all.html"><strong aria-hidden="true">2.5.</strong> Read の処理（全件）</a></li><li class="chapter-item expanded "><a href="day03/crud-read-one.html"><strong aria-hidden="true">2.6.</strong> Read の処理（1 件）</a></li><li class="chapter-item expanded "><a href="day03/crud-update.html"><strong aria-hidden="true">2.7.</strong> Update の処理</a></li><li class="chapter-item expanded "><a href="day03/crud-delete.html"><strong aria-hidden="true">2.8.</strong> Delete の処理</a></li><li class="chapter-item expanded "><a href="day03/summary.html"><strong aria-hidden="true">2.9.</strong> まとめ</a></li></ol></li><li class="chapter-item expanded "><a href="day01/index.html"><strong aria-hidden="true">3.</strong> Day03</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day01/about-react.html"><strong aria-hidden="true">3.1.</strong> React とは</a></li><li class="chapter-item expanded "><a href="day01/construct-app.html"><strong aria-hidden="true">3.2.</strong> アプリケーション実装の準備</a></li><li class="chapter-item expanded "><a href="day01/use-component.html"><strong aria-hidden="true">3.3.</strong> コンポーネント</a></li><li class="chapter-item expanded "><a href="day01/use-props.html"><strong aria-hidden="true">3.4.</strong> props の活用</a></li><li class="chapter-item expanded "><a href="day01/use-router.html"><strong aria-hidden="true">3.5.</strong> router 機能</a></li><li class="chapter-item expanded "><a href="day01/props-function.html"><strong aria-hidden="true">3.6.</strong> 子コンポーネントへの関数入力</a></li><li class="chapter-item expanded "><a href="day01/http-request.html"><strong aria-hidden="true">3.7.</strong> http リクエストの実装</a></li><li class="chapter-item expanded "><a href="day01/ui.html"><strong aria-hidden="true">3.8.</strong> 表示の調整</a></li><li class="chapter-item expanded "><a href="day01/work.html"><strong aria-hidden="true">3.9.</strong> 課題（任意）</a></li></ol></li><li class="chapter-item expanded "><a href="day04/index.html"><strong aria-hidden="true">4.</strong> Day04</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day04/setup-server.html"><strong aria-hidden="true">4.1.</strong> サーバ側の準備</a></li><li class="chapter-item expanded "><a href="day04/create-pages.html"><strong aria-hidden="true">4.2.</strong> 必要な画面の準備</a></li><li class="chapter-item expanded "><a href="day04/tweet-post.html"><strong aria-hidden="true">4.3.</strong> tweet 送信画面の作成</a></li><li class="chapter-item expanded "><a href="day04/tweet-index.html"><strong aria-hidden="true">4.4.</strong> tweet 一覧画面の作成</a></li><li class="chapter-item expanded "><a href="day04/setup-component.html"><strong aria-hidden="true">4.5.</strong> コンポーネントの最適化</a></li><li class="chapter-item expanded "><a href="day04/tweet-find.html"><strong aria-hidden="true">4.6.</strong> tweet 個別表示画面の作成</a></li><li class="chapter-item expanded "><a href="day04/swr-setup.html"><strong aria-hidden="true">4.7.</strong> データ取得タイミングの最適化</a></li><li class="chapter-item expanded "><a href="day04/swr-polling.html"><strong aria-hidden="true">4.8.</strong> データ取得タイミングの調整</a></li><li class="chapter-item expanded "><a href="day04/summary.html"><strong aria-hidden="true">4.9.</strong> まとめ</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">React-Node.js</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day01"><a class="header" href="#day01">Day01</a></h1>
<h2 id="今回のゴール"><a class="header" href="#今回のゴール">今回のゴール</a></h2>
<ul>
<li>Node.js と Express で簡単な API を体験する．</li>
<li>実装のしかたを複数学び，見通しの良いコードの構造を把握する．</li>
<li>サーバで動作する「おみくじ」と「じゃんけん」を実装する．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-とは"><a class="header" href="#nodejs-とは">Node.js とは</a></h1>
<p>サーバで JavaScript を動かす環境のこと．
「Node.js」という言語があるわけではないので認識違いに注意．</p>
<h2 id="web-アプリケーションの仕組みapi-を実装する場合"><a class="header" href="#web-アプリケーションの仕組みapi-を実装する場合">Web アプリケーションの仕組み（API を実装する場合）</a></h2>
<p>基本は「リクエスト」と「レスポンス」．PHP など他の言語と同じ．</p>
<p>サーバ側でリクエストを受ける URI（Uniform Resource Identifier の略．URL とほぼ同義）を用意しておき，そこにクライアント（ブラウザなど）からリクエストを送信する．</p>
<p>リクエストを受けると記述されたコードが実行され，データなどが返される（JSON 形式が多い）．</p>
<h2 id="express"><a class="header" href="#express">Express</a></h2>
<p>Express は Node.js を用いて Web アプリケーションを構築するためのフレームワーク．</p>
<p>Node.js は自由度が非常に高く，そのまま書くと人によって千差万別となる．したがって，Web 開発をするときは Express を使用するのがデファクトスタンダードとなっている状態である（他にもフレームワークは存在するが，Express を基にしたものが多い）．</p>
<p>Express は構造が簡易であり，API の実装も非常に簡単である．今回は Express を使っていくつかの API を実装してみる．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api-実装の準備"><a class="header" href="#api-実装の準備">API 実装の準備</a></h1>
<p>Node.js のプロジェクトを実装し，動かしてみる．</p>
<h2 id="プロジェクト作成"><a class="header" href="#プロジェクト作成">プロジェクト作成</a></h2>
<p>プロジェクトを作成するには，下記のコマンドを実行する．</p>
<pre><code class="language-bash">$ mkdir express-project &amp;&amp; cd express-project
$ npm init
</code></pre>
<p><code>npm</code>は<code>node package module</code>の略であり，Node.js 上で動くパッケージを管理するツールである．Node.js で開発を行う場合はこれを用いることがほとんどである．</p>
<p>ダイアログが出てくるので，答えていく．全部そのまま Enter で OK．</p>
<pre><code class="language-bash">This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt;` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (express-project)
version: (1.0.0)
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to /home/taroosg/Desktop/express-project/package.json:

{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}


Is this OK? (yes)

</code></pre>
<p>完了したらエディタで開く．</p>
<p>エディタで開いたら<code>package.json</code>が作成されているので，中身を確認する．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}

</code></pre>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>name</td><td>プロダクト名．</td></tr>
<tr><td>version</td><td>プロダクトのバージョン．</td></tr>
<tr><td>description</td><td>プロダクトの説明．</td></tr>
<tr><td>main</td><td>プロダクトをパッケージとして公開する場合に入り口となるファイルを指定する．</td></tr>
<tr><td>script</td><td>開発者が任意に作成するコマンド．</td></tr>
<tr><td>auther</td><td>開発者情報．1 人のみ記述する．</td></tr>
<tr><td>license</td><td>ライセンス情報．</td></tr>
</tbody></table>
<h2 id="packagejsonに追記"><a class="header" href="#packagejsonに追記"><code>package.json</code>に追記</a></h2>
<p>下記の内容を追記する．</p>
<pre><code class="language-json">&quot;type&quot;: &quot;module&quot;,
</code></pre>
<p>追記後は以下のような状態．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}

</code></pre>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p><code>package.json</code>に<code>&quot;type&quot;: &quot;module&quot;</code>を追記することで<code>import</code>形式で別ファイルを読みこむことができる．
この追記を行わない場合，外部ファイルを読み込む際には<code>require()</code>関数を用いる．
前回のReactなどでは<code>import</code>が基本となっており，こちらに揃えておいたほうがメリットが大きくオススメである．</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="expressのインストール"><a class="header" href="#expressのインストール">Expressのインストール</a></h1>
<p>今回は Express のフレームワークを使用するため，下記コマンドで</p>
<pre><code class="language-bash">$ npm i express
</code></pre>
<p>実行結果</p>
<pre><code class="language-bash">+ express@4.17.1
added 50 packages from 37 contributors and audited 50 packages in 1.687s
found 0 vulnerabilities

</code></pre>
<p>完了したら，再度<code>package.json</code>を開き，以下の内容が追加されていることを確認する．</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
  &quot;express&quot;: &quot;^4.17.1&quot;
}

</code></pre>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>dependencies</td><td>このプロダクトが依存するパッケージの一覧．</td></tr>
</tbody></table>
<p><code>dependencies</code>の中にインストールしたパッケージが追加される仕組み．パッケージとはいろいろな機能をまとめてインストールできるようにしたものであり，様々なものが公開されている．ライブラリとほぼ同義．</p>
<p>また，インストールされたパッケージは同時に作成される<code>node_modules</code>ディレクトリ内に保存される．このディレクトリはパッケージ専用なので，自分で触ることは殆ど無い．</p>
<p><code>package-lock.json</code>には実際にインストールしたパッケージのバージョンが記載される．基本的に触らない．</p>
<p><code>package.json</code>にはプロダクトに必要なパッケージがすべて記載される．コマンド<code>npm install</code>を実行すると，ここに記載されたパッケージがすべてインストールされる．</p>
<p>プロダクトで使用されているライブラリなどを確認できるため，他の人が書いたコードを見るときもチェックすることをオススメ．</p>
<h2 id="gitignoreファイルの作成"><a class="header" href="#gitignoreファイルの作成"><code>.gitignore</code>ファイルの作成</a></h2>
<p>ソースコードを Git で管理することは周知のことであるが，プロジェクト内には Git で管理したくないファイルやディレクトリも存在する．</p>
<p>例えば，上記で作成された<code>node_modules</code>ディレクトリにはインストールしたパッケージだけでなく，「パッケージが必要としている別のパッケージ」もインストールされる．そのため，これらすべてを Git で管理するとファイル数が膨大になってしまう．</p>
<p>そのため，<code>node_modules</code>ディレクトリ（とその他 Git 管理したくないファイル）を<code>.gitignore</code>と呼ばれるファイルにリストアップすることで Git の管理外に措くことができる．</p>
<p>エディタで<code>.gitignore</code>を作成する．必ずプロジェクト直下に作成すること．</p>
<p>作成したら以下の内容を記述しよう．<code>.gitignore</code>から見た相対パスで Git 管理外にしたいファイルやディレクトリを指定している．</p>
<pre><code class="language-txt">/node_modules
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装1おみくじ初級編"><a class="header" href="#api実装1おみくじ初級編">API実装1（おみくじ初級編）</a></h1>
<h2 id="実行用ファイルの作成"><a class="header" href="#実行用ファイルの作成">実行用ファイルの作成</a></h2>
<p>実行するための<code>app.js</code>ファイルを作成する．エディタから作成すれば OK．</p>
<p>ファイルを作成したら下記の内容を記述する．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;

const app = express();
const port = 3001;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.send(&quot;Hello Node.js!&quot;);
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<p>上記のコードは<code>app.js</code>が実行されると，<code>http://localhost:3001</code>でサーバが立ち上がることを示している．</p>
<p>また，<code>http://localhost:3001/</code>に<code>GET</code>でリクエストが来ると，<code>Hello Node.js!</code>というレスポンスを返すよう記述している．</p>
<h2 id="動作確認"><a class="header" href="#動作確認">動作確認</a></h2>
<p>上記を記述したら，ターミナルで以下のコマンドを実行し，サーバを起動する．実行する際には作業ディレクトリに移動しておくこと．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>実行結果．下記のようにサーバが立ち上がれば成功．</p>
<pre><code class="language-bash">Example app listening at http://localhost:3001
</code></pre>
<p>立ち上がったら，別のターミナルで下記コマンドを実行し，リクエストとレスポンスが適切に処理されることを確認する．</p>
<p>コマンドを実行してメッセージが返ってくれば成功．</p>
<pre><code class="language-bash">$ curl localhost:3001
Hello Node.js!
</code></pre>
<p><code>curl</code>はターミナルから http リクエストを送るコマンド．インストールされていない場合はインストールしておく．</p>
<p>サーバを終了する場合は<code>ctrl + c</code>で終了できる．</p>
<h2 id="uri-の追加"><a class="header" href="#uri-の追加">URI の追加</a></h2>
<p><code>/</code>以外にも URI と作成してみる．</p>
<p><code>app.js</code>を以下のように編集する．<code>/omikuji</code>，<code>/janken</code>の 2 つの URI を追加し，各レスポンスを JSON 形式で返すよう変更している．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;

const app = express();
const port = 3001;

// 編集
app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

// 追加
app.get(&quot;/omikuji&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/omikuji&quot;,
    message: &quot;This is Omikuji URI!&quot;,
  });
});

// 追加
app.get(&quot;/janken&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/janken&quot;,
    message: &quot;This is Janken URI!&quot;,
  });
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="動作確認-1"><a class="header" href="#動作確認-1">動作確認</a></h2>
<p>記述したら，再度下記コマンドでサーバを立ち上げる．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>別のターミナルから，<code>curl</code>コマンドで動作を確認する．</p>
<pre><code class="language-bash">$ curl localhost:3001/
{&quot;uri&quot;:&quot;/&quot;,&quot;message&quot;:&quot;Hello Node.js!&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;This is Omikuji URI!&quot;}

$ curl localhost:3001/janken
{&quot;uri&quot;:&quot;/janken&quot;,&quot;message&quot;:&quot;This is Janken URI!&quot;}

</code></pre>
<p>簡単であるがこれだけで API を実装することができた．</p>
<h2 id="演習おみくじ処理の追加"><a class="header" href="#演習おみくじ処理の追加">【演習】おみくじ処理の追加</a></h2>
<p>実際におみくじの処理を追加してみよう．</p>
<p><code>app.js</code>の以下の部分におみくじの処理を書いて動作を確認しよう．サーバを起動し，以下のような結果になるように実装する．何回か実行して異なる結果が返ってくれば OK！</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;大吉&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;凶&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;中吉&quot;}

</code></pre>
<p>実装例：</p>
<pre><code class="language-js">// app.js

// 省略

app.get(&quot;/omikuji&quot;, (req, res) =&gt; {
  const omikuji = [&quot;大吉&quot;, &quot;中吉&quot;, &quot;小吉&quot;, &quot;凶&quot;, &quot;大凶&quot;];
  const min = 0;
  const max = omikuji.length - 1;
  const index = Math.floor(Math.random() * (max - min + 1)) + min;
  res.json({
    uri: &quot;/omikuji&quot;,
    message: omikuji[index],
  });
});

// 省略

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="コマンドの追加"><a class="header" href="#コマンドの追加">コマンドの追加</a></h1>
<p>ここまで，下記コマンドでサーバを実行していた．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>これとは別に，プロジェクトに対して自分でコマンドを作成することができる．</p>
<p>コマンドを追加する場合は<code>package.json</code>に記述する．下記の内容を追記してみよう．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;__comment&quot;: &quot;↓ここを追記（この行は書かなくてOK）&quot;,
    &quot;start&quot;: &quot;node app.js&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;^4.17.1&quot;
  }
}
</code></pre>
<p>このように記述すると，<code>npm start</code>というコマンドを実行すると<code>node app.js</code>が実行される．</p>
<p>プロジェクトが複雑になると，場面に応じて様々なコマンドを実行したい場合がある．そのようなときに，統一されたコマンドを準備しておくことで開発をスムーズに進めることができる．</p>
<p>下記を実行するとサーバが立ち上がる．これまでと同じ動作であることを確認しよう．</p>
<pre><code class="language-bash">$ npm start
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装2おみくじ中級編"><a class="header" href="#api実装2おみくじ中級編">API実装2（おみくじ中級編）</a></h1>
<p>簡単な API を実装するだけならば，ここまでの内容で十分である．おみくじの処理部分に適当な記述をすれば問題ないであろう．</p>
<p>しかし，コードの記述量が増えてくると，見通しが悪くなってしまい，保守管理にも支障をきたす．</p>
<p>そこで，処理中の役割毎に別ファイルに記述できるようにディレクトリ構成を変更する（責務の分離，などと呼ばれる）．</p>
<h2 id="ディレクトリ構造と役割"><a class="header" href="#ディレクトリ構造と役割">ディレクトリ構造と役割</a></h2>
<p>大きく<code>routes</code>，<code>controllers</code>，<code>services</code>の 3 つに分離する．DB などと組み合わせてデータを扱う場合は他に<code>model</code>を用意するが今回は省略する．</p>
<p>各要素の役割は以下の通り．</p>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>routes</td><td>URI と実行する処理の対応．</td></tr>
<tr><td>controllers</td><td>リクエストパラメータの検証，レスポンス送信．</td></tr>
<tr><td>services</td><td>リクエストに対する処理のメインロジックを記述．</td></tr>
<tr><td>repositories</td><td>DB関連の処理を記述．今回は出番なし．</td></tr>
</tbody></table>
<p>このような役割分担とするため，以下のようにディレクトリとファイルを作成する．</p>
<pre><code class="language-bash">.
├── app.js
├── controllers
│   └── omikuji.controller.js
├── node_modules
├── package.json
├── package-lock.json
├── routes
│   └── omikuji.route.js
└── services
    └── omikuji.service.js

</code></pre>
<h2 id="実行ファイルの実装"><a class="header" href="#実行ファイルの実装">実行ファイルの実装</a></h2>
<p><code>app.js</code>を以下のように編集する．</p>
<p>ルーティングは routes 以下のファイルに任せ，指定したファイルを読み込むよう記述．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;
// おみくじのrouterを読み込む
import { omikujiRouter } from &quot;./routes/omikuji.route.js&quot;;

const app = express();
const port = 3001;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

// おみくじのルーティングを変更
app.use(&quot;/omikuji&quot;, (req, res) =&gt; omikujiRouter(req, res));

app.get(&quot;/janken&quot;, (req, res) =&gt; {
  res.json({ message: &quot;This is Janken URI!&quot; });
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="ルーティングの実装"><a class="header" href="#ルーティングの実装">ルーティングの実装</a></h2>
<p><code>routes/omikuji.route.js</code>に以下の内容を記述する．</p>
<p>URI と対応するコントローラの処理を記述する．</p>
<pre><code class="language-js">// routes/omikuji.route.js

import express from &quot;express&quot;;
import { getResult } from &quot;../controllers/omikuji.controller.js&quot;

export const omikujiRouter = express.Router();

omikujiRouter.get(&quot;/&quot;, (req, res) =&gt; getResult(req, res));

</code></pre>
<h2 id="コントローラの実装"><a class="header" href="#コントローラの実装">コントローラの実装</a></h2>
<p><code>controllers/omikuji.controller.js</code>に以下の内容を記述する．</p>
<p>サービスを呼び出して実行したいメソッドを指定し，結果によってレスポンスを指定する．</p>
<pre><code class="language-js">// controllers/omikuji.controller.js

import { getOmikuji } from &quot;../services/omikuji.service.js&quot;;

export const getResult = async (req, res, next) =&gt; {
  try {
    const result = await getOmikuji({});
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully get Omikuji!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの実装"><a class="header" href="#サービスの実装">サービスの実装</a></h2>
<p><code>services/omikuji.service.js</code>に以下の内容を記述する．</p>
<p>サービスでは実行したいロジックを書く．ここでおみくじのロジックを実装している．</p>
<pre><code class="language-js">// services/omikuji.service.js

export const getOmikuji = async (query) =&gt; {
  try {
    const omikuji = [&quot;大吉&quot;, &quot;中吉&quot;, &quot;小吉&quot;, &quot;凶&quot;, &quot;大凶&quot;];
    const min = 0;
    const max = omikuji.length - 1;
    const index = Math.floor(Math.random() * (max - min + 1)) + min;
    return { result: omikuji[index] };
  } catch (e) {
    throw Error(&quot;Error while getting Omikuji.&quot;);
  }
};

</code></pre>
<p>処理の順序としては以下のようになる．</p>
<pre><code class="language-txt">リクエスト               レスポンス
   ↓                       ↑
routes/omikuji.route.js    |
   ↓                       |
controllers/omikuji.controller.js
   ↓           ↑
ervices/omikuji.service.js

</code></pre>
<h2 id="動作確認-2"><a class="header" href="#動作確認-2">動作確認</a></h2>
<p>サーバを立ち上げ，以下のコマンドでリクエストを送信する．</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
</code></pre>
<p>おみくじの結果が返ってくれば成功．数回実行し，異なる結果が返ってくることを確認しておこう．</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;凶&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;大凶&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;中吉&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;大吉&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

</code></pre>
<p>ユーザに返すレスポンスを変更したい場合はコントローラを，処理の内容を更新したい場合はサービスを書き換えれば良い．このように，各責務を別の場所に置くことでメンテナンスしやすいプロダクトになる．</p>
<p>これでおみくじの実装は完了である．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装3じゃんけん"><a class="header" href="#api実装3じゃんけん">API実装3（じゃんけん）</a></h1>
<p>おみくじの実装ができたので，ユーザ側からデータを送信してじゃんけんの結果を返す API を実装してみる．</p>
<h2 id="アプリケーションの全体像"><a class="header" href="#アプリケーションの全体像">アプリケーションの全体像</a></h2>
<p>ユーザはリクエスト時に<code>post</code>メソッドで自分の手を送信する．サーバ側はユーザから送信された手に対してランダムで手を出し，「ユーザの手」「サーバの手」「勝敗」をレスポンスで返却する．</p>
<p>下図を参考に，必要なファイルを作成する．</p>
<pre><code class="language-bash">.
├── app.js
├── controllers
│   ├── janken.controller.js
│   └── omikuji.controller.js
├── node_modules
├── package.json
├── package-lock.json
├── routes
│   ├── janken.route.js
│   └── omikuji.route.js
└── services
    ├── janken.service.js
    └── omikuji.service.js

</code></pre>
<h2 id="各ファイルの実装"><a class="header" href="#各ファイルの実装">各ファイルの実装</a></h2>
<p><code>app.js</code>を以下のように編集する．</p>
<p>じゃんけんのルーティングを読み込む．また，POST メソッドでデータを受け取るためには<code>express.urlencoded({ extended: true })</code>とJSONデータの扱いで<code>express.json()</code>が必要になるため読み込んでいる．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;
import { omikujiRouter } from &quot;./routes/omikuji.route.js&quot;;
// じゃんけんのルーティングを読み込む
import { jankenRouter } from &quot;./routes/janken.route.js&quot;;

const app = express();
// ↓POSTでデータを受け取るために必要
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

const port = 3001;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

app.use(&quot;/omikuji&quot;, (req, res) =&gt; omikujiRouter(req, res));
// じゃんけんのルーティングを追加
app.use(&quot;/janken&quot;, (req, res) =&gt; jankenRouter(req, res));

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="ルーティングの実装-1"><a class="header" href="#ルーティングの実装-1">ルーティングの実装</a></h2>
<p><code>routes/janken.route.js</code>に以下の内容を記述する．</p>
<p>URI と対応するコントローラの処理を記述する．今回は POST で受け取る点と送信されてきたデータが<code>req</code>に入っている点に注意．</p>
<pre><code class="language-js">// routes/janken.route.js

import express from &quot;express&quot;;
import { getResult } from &quot;../controllers/janken.controller.js&quot;;

export const jankenRouter = express.Router();

jankenRouter.post(&quot;/&quot;, (req, res) =&gt; getResult(req, res));

</code></pre>
<h2 id="コントローラの実装-1"><a class="header" href="#コントローラの実装-1">コントローラの実装</a></h2>
<p><code>controllers/janken.controller.js</code>に以下の内容を記述する．</p>
<p>おみくじの場合とほぼ同じ．</p>
<pre><code class="language-js">// controllers/janken.controller.js

import { getJanken } from &quot;../services/janken.service.js&quot;;

export const getResult = async (req, res, next) =&gt; {
  try {
    const result = await getJanken(req.body);
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully get Janken!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの実装-1"><a class="header" href="#サービスの実装-1">サービスの実装</a></h2>
<p><code>services/janken.service.js</code>に以下の内容を記述する．</p>
<p>とりあえず毎回同じ結果を返している．</p>
<pre><code class="language-js">// services/janken.service.js

export const getJanken = async (query) =&gt; {
  try {
    return { yourHand: query.myhand, comHand: &quot;グー&quot;, result: &quot;テスト中&quot; };
  } catch (e) {
    throw Error(&quot;Error while getting Janken&quot;);
  }
};

</code></pre>
<h2 id="動作確認-3"><a class="header" href="#動作確認-3">動作確認</a></h2>
<p>サーバを立ち上げて，<code>curl</code>コマンドでリクエストを送信する．POST する場合は下記の書式で実行する．</p>
<p>結果が返ってくれば成功．</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;パー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;パー&quot;,&quot;comHand&quot;:&quot;グー&quot;,&quot;result&quot;:&quot;テスト中&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}
</code></pre>
<p>サーバに対して<code>{&quot;myhand&quot;:&quot;パー&quot;}</code>という JSON 形式のデータを POST メソッドで送信している．</p>
<h2 id="演習じゃんけんの実装"><a class="header" href="#演習じゃんけんの実装">【演習】じゃんけんの実装</a></h2>
<p>上記で記述した<code>services/janken.service.js</code>にじゃんけんのロジックを実装してみよう．</p>
<p>サーバを立ち上げて，以下のようにじゃんけんができれば OK！</p>
<pre><code class="language-js">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;グー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;グー&quot;,&quot;comHand&quot;:&quot;チョキ&quot;,&quot;result&quot;:&quot;Win&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;チョキ&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;チョキ&quot;,&quot;comHand&quot;:&quot;パー&quot;,&quot;result&quot;:&quot;Win&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;パー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;パー&quot;,&quot;comHand&quot;:&quot;チョキ&quot;,&quot;result&quot;:&quot;Lose&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

</code></pre>
<p>じゃんけんができたら，グーチョキパー以外の手を送信すると NG なメッセージが返す実装にもチャレンジ！</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;無敵のアレ&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;message&quot;:&quot;Invalid hand...&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

</code></pre>
<p>実装例：</p>
<pre><code class="language-js">// services/janken.service.js

export const getJanken = async (query) =&gt; {
  try {
    const hand = [&quot;グー&quot;, &quot;チョキ&quot;, &quot;パー&quot;];
    const myIndex = hand.indexOf(query.myhand);
    if (myIndex === -1) return { message: &quot;Invalid hand...&quot; };
    const comIndex = Math.floor(Math.random() * 3);
    const resultSheet = [
      [&quot;Draw&quot;, &quot;Win&quot;, &quot;Lose&quot;],
      [&quot;Lose&quot;, &quot;Draw&quot;, &quot;Win&quot;],
      [&quot;Win&quot;, &quot;Lose&quot;, &quot;Draw&quot;],
    ];
    return {
      yourHand: query.myhand,
      comHand: hand[comIndex],
      result: resultSheet[myIndex][comIndex],
    };
  } catch (e) {
    throw Error(&quot;Error while getting Janken&quot;);
  }
};

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h1>
<p>今回は Node.js を用いて API サーバを実装してみた．</p>
<p>おみくじやじゃんけんの実装を通じて，必要な処理に含まれる責務を分離し，別々のファイルに実装した．</p>
<p>Node.js はシンプルな構成で柔軟な API を構築できる魅力的な技術である．興味を持った方は，じゃんけんの勝率変更や DB 連携などにも挑戦してみると良いだろう．</p>
<p>今回は以上である( `･ω･)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="day02"><a class="header" href="#day02">Day02</a></h1>
<h2 id="今回のゴール-1"><a class="header" href="#今回のゴール-1">今回のゴール</a></h2>
<ul>
<li>Cloud Firestore を用いたデータの永続化を実装する．</li>
<li>「twitter のようななにか」を実装し，CRUD 処理とデータの構造を把握する．</li>
<li>DB 操作を行う際のアーキテクチャについて知る．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="データの永続化について"><a class="header" href="#データの永続化について">データの永続化について</a></h1>
<h2 id="nodejs-におけるデータ永続化"><a class="header" href="#nodejs-におけるデータ永続化">Node.js におけるデータ永続化</a></h2>
<p>データの永続化とは，アプリケーションの状態によらずデータを保持することである．言い換えると，DB などの外部にデータを保存すること．</p>
<p>データの永続化に使用する外部 DB は次のようなものがある．Node.js ではいずれの DB も利用できるが，RDB であれば MySQL か PostgreSQL，NoSQL では MongoDB，Firebase，Redis などがよく用いられる．</p>
<h2 id="rdb"><a class="header" href="#rdb">RDB</a></h2>
<p>SQL を用いてデータ管理を行う DB．柔軟な集計や結合ができ，情報も多い．</p>
<p>基本的には同じ SQL を記述すれば同じ動作が実行されるが，それぞれの DB で仕様が異なる部分もあるので使用前は要チェックすべし．</p>
<p>できることは非常に幅広く，データを扱う上でできないことはほぼないと考えて良い．</p>
<h3 id="例"><a class="header" href="#例">例</a></h3>
<ul>
<li>MySQL</li>
<li>PostgreSQL</li>
<li>OracleDB</li>
</ul>
<h2 id="nosql"><a class="header" href="#nosql">NoSQL</a></h2>
<p>Not Only SQL．SQL を前提としたデータ構造に縛られない DB．「値」およびそれを取得するための「キー」だけを格納できる Key-Value 型の DB などが代表的だ．</p>
<p>下記の例においてもそれぞれデータ構造が異なるため，プロジェクトの目的に合致した DB を選択する必要がある．</p>
<p>RDB と比較して後発のためにより直感的に扱えるものが多い一方で，データの格納および取得が高度に最適化されているが故に，機能性を最小限にしているものもある．</p>
<ul>
<li>MongoDB</li>
<li>Firebase Firestore Database</li>
<li>Firebase Realtime Database</li>
<li>Redis</li>
<li>DynamoDB</li>
<li>Neo4j</li>
</ul>
<h2 id="使い分け"><a class="header" href="#使い分け">使い分け</a></h2>
<p>ケースバイケース．</p>
<p>アプリケーションが実現したい機能を明確にし，相性が良い方を選択する．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="firestore-の準備"><a class="header" href="#firestore-の準備">Firestore の準備</a></h1>
<h2 id="firestore-database-の準備"><a class="header" href="#firestore-database-の準備">Firestore Database の準備</a></h2>
<p>今回は NoSQL である Firebase Firestore Database を用いて CRUD 処理を実装してみる．</p>
<p>DB がオンライン上にあるので，環境問わず使えるところが魅力．</p>
<h2 id="db-の作成"><a class="header" href="#db-の作成">DB の作成</a></h2>
<ul>
<li>Firebase のコンソールにアクセスし，今回のプロジェクトのページを表示．</li>
<li>左側メニューの「Firestore Database」をクリックし，DB を作成する．必ず「テストモード」にチェックを入れて作成すること．リージョンは任意．</li>
</ul>
<h2 id="json-ファイルのダウンロード"><a class="header" href="#json-ファイルのダウンロード">JSON ファイルのダウンロード</a></h2>
<p>Node.js で Firestore を操作するには，設定ファイルを用意する必要がある．Firebase で適当なプロジェクトを作成したら，下記の手順で必要なファイルをダウンロードする．</p>
<ol>
<li>Firebase のコンソールにアクセスし，今回のプロジェクトのページを表示．</li>
<li>⚙ -&gt; プロジェクトを設定 で設定画面を表示．</li>
<li>「サービスアカウント」タブ -&gt; 「サービスアカウントを作成」ボタン -&gt; 「新しい秘密鍵の作成」ボタン -&gt; 「キーの生成」ボタンの順にクリック．</li>
<li>適当な場所（デスクトップなど）に json ファイルを保存する．</li>
<li>コンソール画面は開いたままにしておこう．</li>
</ol>
<h2 id="json-ファイルの配置と構成ファイルの作成"><a class="header" href="#json-ファイルの配置と構成ファイルの作成">JSON ファイルの配置と構成ファイルの作成</a></h2>
<ul>
<li>プロジェクト直下に<code>model</code>ディレクトリを作成する．<code>model</code>ディレクトリの中に ↑ でダウンロードした json ファイルを移動する．</li>
<li><code>model</code>ディレクトリの中に<code>firebase.js</code>ファイルを作成する．</li>
<li>下記の内容を記述する．</li>
<li><code>const serviceAccount = require('...');</code>の部分の<code>require()</code>内を json ファイルのパスに書き換える．</li>
</ul>
<p><code>firebase.js</code>は以下のような状態．</p>
<pre><code class="language-js">import admin from 'firebase-admin';
import { createRequire } from 'module';

const require = createRequire(import.meta.url)
const serviceAccount = require('./hoge-firebase-adminsdk-fuga-piyo.json')

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount)
});

export default admin;

</code></pre>
<h2 id="gitignoreに追記"><a class="header" href="#gitignoreに追記"><code>.gitignore</code>に追記</a></h2>
<p>ダウンロードした JSON ファイルには Firebase プロジェクトの情報が含まれているため， GitHub に push しないよう Git 管理から外しておく．</p>
<p>サーバにデプロイする場合にも必要になるため，その場合は環境変数などを使用して工夫する必要がある．</p>
<pre><code>/node_modules
/model/hoge-firebase-adminsdk-fuga-piyo.json
</code></pre>
<h2 id="必要なパッケージのインストール"><a class="header" href="#必要なパッケージのインストール">必要なパッケージのインストール</a></h2>
<p>下記コマンドでインストールする．必ずプロジェクトのディレクトリで行うこと．</p>
<p>エラーがでなければOK．</p>
<pre><code class="language-bash">$ npm i firebase-admin

added 168 packages, and audited 334 packages in 8s

12 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ファイル作成と動作確認"><a class="header" href="#ファイル作成と動作確認">ファイル作成と動作確認</a></h1>
<h2 id="ルーティング表"><a class="header" href="#ルーティング表">ルーティング表</a></h2>
<p>これから実装していく機能は以下のとおり．基本的なCRUD処理を実装する．</p>
<table><thead><tr><th>URI</th><th>method</th><th>name</th><th>description</th></tr></thead><tbody>
<tr><td><code>/tweet</code></td><td>GET</td><td>findAll</td><td>データ全件取得</td></tr>
<tr><td><code>/tweet/:id</code></td><td>GET</td><td>find</td><td>データ1件取得</td></tr>
<tr><td><code>/tweet</code></td><td>POST</td><td>store</td><td>データ作成処理</td></tr>
<tr><td><code>/tweet/:id</code></td><td>PUT</td><td>update</td><td>データ更新処理</td></tr>
<tr><td><code>/tweet/:id</code></td><td>DELETE</td><td>destroy</td><td>データ削除処理</td></tr>
</tbody></table>
<h2 id="役割分担"><a class="header" href="#役割分担">役割分担</a></h2>
<p>前回講義の役割分担表も参照．今回は repository に DB 関連の処理を実装する．</p>
<p>repository に DB 関連の処理を任せることで，DB が変更された場合でも他のコードの影響せずに運用することができる．このような役割分担をリポジトリパターンと呼ぶ．</p>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>routes</td><td>URI と実行する処理の対応．</td></tr>
<tr><td>controllers</td><td>リクエストパラメータの検証，レスポンス送信．</td></tr>
<tr><td>services</td><td>リクエストに対する処理のメインロジックを記述．</td></tr>
<tr><td>repositories</td><td>DB関連の処理を記述．今回は Firestore Database とやり取りする処理を記述する．</td></tr>
</tbody></table>
<h2 id="既存ファイルへの追記と新規ファイルの準備"><a class="header" href="#既存ファイルへの追記と新規ファイルの準備">既存ファイルへの追記と新規ファイルの準備</a></h2>
<p><code>app.js</code>にルーティングを追記する．</p>
<pre><code class="language-js">// app.js

import express from 'express';
import { omikujiRouter } from './routes/omikuji.route.js';
import { jankenRouter } from './routes/janken.route.js';
// ↓追加
import { tweetRouter } from './routes/tweet.route.js';

const app = express();

const app = express();
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
const port = 3001;

app.get('/', (req, res) =&gt; {
  res.json({
    uri: '/',
    message: 'Hello Node.js!',
  });
});

app.use('/omikuji', (req, res) =&gt; omikujiRouter(req, res));
app.use('/janken', (req, res) =&gt; jankenRouter(req, res));
// ↓追加
app.use('/tweet', (req, res) =&gt; tweetRouter(req, res));

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="必要なファイルの作成"><a class="header" href="#必要なファイルの作成">必要なファイルの作成</a></h2>
<p>新しく以下のファイルを作成する．前回の役割に加えて，今回は DB 関連の処理が必要となるため <code>repositories</code> フォルダを作成してファイルを追加する．</p>
<ul>
<li><code>routes/tweet.route.js</code></li>
<li><code>controllers/tweet.controller.js</code></li>
<li><code>services/tweet.service.js</code></li>
<li><code>repositories/tweet.repository.js</code></li>
</ul>
<p>まずそれぞれのファイルが連携できることを確認するため，DB と接続せずに固定のデータを返す処理を実装する．</p>
<h2 id="ルーティングの作成"><a class="header" href="#ルーティングの作成">ルーティングの作成</a></h2>
<p>まずはルーティングを作成．</p>
<pre><code class="language-js">// routes/tweet.route.js

import express from 'express';
import { readAllTweetData } from '../controllers/tweet.controller.js';

export const tweetRouter = express.Router();

tweetRouter.get('/', (req, res) =&gt; readAllTweetData(req, res));

</code></pre>
<h2 id="コントローラの作成"><a class="header" href="#コントローラの作成">コントローラの作成</a></h2>
<p>コントローラではリクエストとレスポンスを定義．</p>
<pre><code class="language-js">// controllers/tweet.controller.js

import { getAllTweetData } from '../services/tweet.service.js';

export const readAllTweetData = async (req, res, next) =&gt; {
  try {
    const result = await getAllTweetData();
    return res.status(200).json({
      status: 200,
      result: result,
      message: 'Succesfully get All Tweet Data!',
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの作成"><a class="header" href="#サービスの作成">サービスの作成</a></h2>
<p>サービスではリポジトリの関数（<code>findAll()</code>）を呼び出す．</p>
<pre><code class="language-js">// services/tweet.service.js

import { findAll } from '../repositories/tweet.repository.js';

export const getAllTweetData = async () =&gt; {
  try {
    return findAll();
  } catch (e) {
    throw Error('Error while getting All Tweet Data');
  }
};

</code></pre>
<h2 id="リポジトリの作成"><a class="header" href="#リポジトリの作成">リポジトリの作成</a></h2>
<p>リポジトリは一旦決まったメッセージを返す．</p>
<pre><code class="language-js">// repositories/tweet.repository.js

export const findAll = () =&gt; {
  return { message: 'OK' };
};

</code></pre>
<h2 id="動作確認-4"><a class="header" href="#動作確認-4">動作確認</a></h2>
<p>動作確認する．以下のコマンドでレスポンスが返ってくれば OK．</p>
<pre><code class="language-bash">$ curl localhost:3001/tweet

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;message&quot;: &quot;OK&quot;
  },
  &quot;message&quot;: &quot;Succesfully get All Tweet Data!&quot;
}

</code></pre>
<p>一通りの動作が確認できたら，続いて Firestore の CRUD 処理を作成していく．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="create-の処理"><a class="header" href="#create-の処理">Create の処理</a></h1>
<h2 id="create-処理の流れ"><a class="header" href="#create-処理の流れ">Create 処理の流れ</a></h2>
<p>はじめは Create の処理を実装する．クライアントから送信されたデータを DB に保存する一連の流れを書く．</p>
<p>今回は<code>POST</code>メソッドでデータを送信し，新規レコードを作成する．</p>
<h2 id="ルーティングの作成-1"><a class="header" href="#ルーティングの作成-1">ルーティングの作成</a></h2>
<p>ルーティングでは，collection 名とデータを受け取り，コントローラにデータを渡す．</p>
<pre><code class="language-js">// routes/tweet.route.js

import express from 'express';
import { readAllTweetData, createTweetData } from '../controllers/tweet.controller.js';

export const tweetRouter = express.Router();

tweetRouter.get('/', (req, res) =&gt; readAllTweetData(req, res));
// ↓追加
tweetRouter.post('/', (req, res) =&gt; createTweetData(req, res));

</code></pre>
<h2 id="コントローラの作成-1"><a class="header" href="#コントローラの作成-1">コントローラの作成</a></h2>
<p>コントローラでは，データを整理してサービスに渡す．また，サービスの処理結果を元にレスポンスを返す．</p>
<pre><code class="language-js">// controllers/tweet.controller.js

import { getAllTweetData, insertTweetData } from '../services/tweet.service.js'

export const readAllTweetData = async (req, res, next) =&gt; {
  // 省略
};

// ↓追加
export const createTweetData = async (req, res, next) =&gt; {
  try {
    const { tweet, user_id } = req.body;
    if (!(tweet &amp;&amp; user_id)) {
      throw new Error('something is blank');
    }
    const result = await insertTweetData({
      data: { tweet: tweet, user_id: Number(user_id) },
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: 'Succesfully post Tweet Data!',
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの作成-1"><a class="header" href="#サービスの作成-1">サービスの作成</a></h2>
<p>サービスではロジックが必要な場合は記述するが，今回はデータをそのまま渡すだけ．実際に Firebase にデータを保存する処理は<code>repositories</code>レイヤーに分割する．</p>
<pre><code class="language-js">// services/tweet.service.js

import { findAll, store } from '../repositories/tweet.repository.js';

export const getAllTweetData = async () =&gt; {
  // 省略
};

export const insertTweetData = async ({ data }) =&gt; {
  try {
    const ref = await store({ data: data });
    return {
      id: ref.id,
      data: data,
    };
  } catch (e) {
    throw Error('Error while posting Tweet Data');
  }
};

</code></pre>
<h2 id="リポジトリの作成-1"><a class="header" href="#リポジトリの作成-1">リポジトリの作成</a></h2>
<p>collection を指定してデータを保存する処理を実装する．ここで Firestore 関連のコードを記述する必要があるため，関連するコードを import する．</p>
<p>データ永続化に関するコードをリポジトリのレイヤーに閉じ込めることで，DB の種類が変更された場合にもコントローラやサービスのコードに影響ない状態にすることができる．</p>
<p>Firestore に関するポイントは以下のとおり．</p>
<ul>
<li>
<p><code>created_at</code>と<code>updated_at</code>は Firestore の独自形式となるため，ここでユーザが送信してきたデータとマージしている．</p>
</li>
<li>
<p>collection が存在しない場合は自動的に作成される．処理が実行されると，作成された Document の ID と追加データが返される．</p>
</li>
</ul>
<pre><code class="language-js">// repositories/tweet.repository.js

import admin from '../model/firebase.js';
const db = admin.firestore();

export const findAll = () =&gt; {
  return { message: 'OK' };
};

export const store = async ({ data }) =&gt; {
  try {
    const postData = {
      ...data,
      created_at: admin.firestore.Timestamp.now(),
      updated_at: admin.firestore.Timestamp.now(),
    };
    const ref = await db.collection('tweet').add(postData);
    return ref;
  } catch (e) {
    throw Error('Error while store Tweet Data');
  }
};

</code></pre>
<h2 id="動作確認-5"><a class="header" href="#動作確認-5">動作確認</a></h2>
<p>処理を追加したら動作確認する．サーバを起動して下記コマンドでデータを送信し，成功のレスポンスが返ってくれば OK．</p>
<p>また，ブラウザで Firebase のコンソール画面から Firestore にアクセスし，送信したデータが保存されていることを確認しておく．</p>
<p>動作が確認できたら，2-3 件データを入れておこう．</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;tweet&quot;:&quot;node.js&quot;,&quot;user_id&quot;:1}' localhost:3001/tweet

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;id&quot;: &quot;XMr6sQ26x99QVvSaHewe&quot;,
    &quot;data&quot;: {
      &quot;tweet&quot;: &quot;node.js&quot;,
      &quot;user_id&quot;: 1
    }
  },
  &quot;message&quot;: &quot;Succesfully post Tweet Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="read-の処理全件"><a class="header" href="#read-の処理全件">Read の処理（全件）</a></h1>
<h2 id="データ全件取得の処理"><a class="header" href="#データ全件取得の処理">データ全件取得の処理</a></h2>
<p>Read の処理では，ルーティングとコントローラとサービスははじめにつくったものを使用する．</p>
<p>リポジトリに以下の内容を記述する．collection 名を指定してデータをすべて取得する．日付部分は独自形式なので，データ取得後に<code>Date</code>形式に変換している．</p>
<p><code>tweetSnapshot</code>は取得したデータそのままで使いにくいので，必要な部分を取り出して<code>tweets</code>に入れている．</p>
<p>また，Firestore の<code>created_at</code>と<code>updated_at</code>はそのままだと使いづらいので<code>.toData()</code>で変換している．</p>
<pre><code class="language-js">// repositories/tweet.repository.js

import admin from '../model/firebase.js';
const db = admin.firestore();

export const findAll = async () =&gt; {
  try {
    const tweetSnapshot = await db.collection('tweet').get();
    const tweets = tweetSnapshot.docs.map((x) =&gt; {
      return {
        id: x.id,
        data: {
          ...x.data(),
          created_at: x.data().created_at.toDate(),
          updated_at: x.data().updated_at.toDate(),
        },
      };
    });
    return tweets;
  } catch (e) {
    throw Error('Error while getting Tweet Data');
  }
};

export const store = async ({ data }) =&gt; {
  // 省略
};

</code></pre>
<h2 id="動作確認全件取得"><a class="header" href="#動作確認全件取得">動作確認（全件取得）</a></h2>
<p>記述したら動作確認する．下記コマンドを実行して，保存されているデータが全件取得できれば OK（下記はデータ 2 件登録時の例）．</p>
<pre><code class="language-bash">$ curl localhost:3001/tweet

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: &quot;1JXLilqdOqU7rCrwjEpA&quot;,
      &quot;data&quot;: {
        &quot;tweet&quot;: &quot;node.js&quot;,
        &quot;created_at&quot;: &quot;2021-07-29T11:38:38.005Z&quot;,
        &quot;user_id&quot;: 1,
        &quot;updated_at&quot;: &quot;2021-07-29T11:38:38.006Z&quot;
      }
    },
    {
      &quot;id&quot;: &quot;CfTIWGVsuZGOa3nZippY&quot;,
      &quot;data&quot;: {
        &quot;created_at&quot;: &quot;2021-07-29T11:39:09.948Z&quot;,
        &quot;updated_at&quot;: &quot;2021-07-29T11:39:09.949Z&quot;,
        &quot;user_id&quot;: 1,
        &quot;tweet&quot;: &quot;React&quot;
      }
    }
  ],
  &quot;message&quot;: &quot;Succesfully get All Tweet Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="read-の処理1件"><a class="header" href="#read-の処理1件">Read の処理（1件）</a></h1>
<h2 id="データ1件取得の処理"><a class="header" href="#データ1件取得の処理">データ1件取得の処理</a></h2>
<p>前項でデータを全件取得する処理を実装したので，次はidを指定して1件のデータを取得する処理を実装する．</p>
<p>Firestore Database はドキュメントの id がわかれば指定の1件を取得できるため，クライアント側から GET で id の文字列を送信し，データを取得する流れとなる．</p>
<p>（他の RDB などでも id がわかれば指定のレコードを取得できるため，処理の流れは同様である．）</p>
<h2 id="ルーティングの作成-2"><a class="header" href="#ルーティングの作成-2">ルーティングの作成</a></h2>
<blockquote>
<p><strong>Key Point</strong>💡</p>
<p><code>:id</code>はユーザが付加したパラメータを指定する．コントローラで<code>req.params.id</code>で取得する．</p>
</blockquote>
<pre><code class="language-js">// routes/tweet.route.js

import express from 'express';
import { readAllTweetData, readOneTweetData, createTweetData } from '../controllers/tweet.controller.js';

export const tweetRouter = express.Router();

tweetRouter.get('/', (req, res) =&gt; readAllTweetData(req, res));
// ↓追加
tweetRouter.get('/:id', (req, res) =&gt; readOneTweetData(req, res));
tweetRouter.post('/', (req, res) =&gt; createTweetData(req, res));

</code></pre>
<h2 id="コントローラの作成-2"><a class="header" href="#コントローラの作成-2">コントローラの作成</a></h2>
<p>URLに付加したidを<code>req.params.id</code>で取得する．サービスに id を渡す．</p>
<pre><code class="language-js">// controllers/tweet.controller.js

import { getAllTweetData, getOneTweetData, insertTweetData } from '../services/tweet.service.js';

export const readAllTweetData = async (req, res, next) =&gt; {
  // 省略
};

// ↓追加
export const readOneTweetData = async (req, res, next) =&gt; {
  try {
    const { id } = req.params;
    const result = await getOneTweetData({ id: id, });
    return res.status(200).json({
      status: 200,
      result: result,
      message: 'Succesfully get One Tweet Data!',
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

export const createTweetData = async (req, res, next) =&gt; {
  // 省略
};

</code></pre>
<h2 id="サービスの作成-2"><a class="header" href="#サービスの作成-2">サービスの作成</a></h2>
<p>今回は特にロジックなし．リポジトリの処理に id を渡す．</p>
<pre><code class="language-js">// services/tweet.service.js

import { findAll, find, store } from '../repositories/tweet.repository.js';

export const getAllTweetData = async () =&gt; {
  // 省略
};

// ↓追加
export const getOneTweetData = async ({ id }) =&gt; {
  try {
    return find({ id: id });
  } catch (e) {
    throw Error('Error while getting One Tweet Data');
  }
};

export const insertTweetData = async ({ data }) =&gt; {
  // 省略
};

</code></pre>
<h2 id="リポジトリの作成-2"><a class="header" href="#リポジトリの作成-2">リポジトリの作成</a></h2>
<p>id を受け取ったら，コレクション名とドキュメント id を指定して<code>.get()</code>でデータを取得できる．</p>
<p>取得したデータは不要なものも含まれているので，必要なもののみ取り出して日付時刻を扱いやすい形式に変換する．</p>
<pre><code class="language-js">// repositories/tweet.repository.js

import admin from '../model/firebase.js';
const db = admin.firestore();

export const findAll = async () =&gt; {
  // 省略
};

// ↓追加
export const find = async ({ id }) =&gt; {
  try {
    const tweetSnapshot = await db.collection('tweet').doc(id).get();
    return {
      id: tweetSnapshot.id,
      data: {
        ...tweetSnapshot.data(),
        created_at: tweetSnapshot.data().created_at.toDate(),
        updated_at: tweetSnapshot.data().updated_at.toDate(),
      }
    }
  } catch (e) {
    throw Error('Error while getting One tweet Data');
  }
};

export const store = async ({ data }) =&gt; {
  // 省略
};

</code></pre>
<h2 id="動作確認1-件取得"><a class="header" href="#動作確認1-件取得">動作確認（1 件取得）</a></h2>
<p>下記コマンドで動作をチェック．全件取得した中から適当なidを入力し，該当のデータが取得できればOK．</p>
<pre><code class="language-bash">$ curl localhost:3001/tweet/1JXLilqdOqU7rCrwjEpA

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;id&quot;: &quot;1JXLilqdOqU7rCrwjEpA&quot;,
    &quot;data&quot;: {
      &quot;updated_at&quot;: &quot;2021-07-29T11:38:38.006Z&quot;,
      &quot;user_id&quot;: 1,
      &quot;created_at&quot;: &quot;2021-07-29T11:38:38.005Z&quot;,
      &quot;tweet&quot;: &quot;node.js&quot;
    }
  },
  &quot;message&quot;: &quot;Succesfully get One Tweet Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="update-の処理"><a class="header" href="#update-の処理">Update の処理</a></h1>
<h2 id="データ更新の処理"><a class="header" href="#データ更新の処理">データ更新の処理</a></h2>
<p>既存のデータを上書きする処理を実装する．<code>PUT</code>形式でデータを送信する．</p>
<blockquote>
<p><strong>Key Point</strong>💡</p>
<p><code>PUT</code>形式は<code>GET</code>と<code>POST</code>が合わさったような形式で，<code>req.params.id</code>で id を送信し，同時に<code>req.body</code>で上書きするデータを送信する．</p>
</blockquote>
<h2 id="ルーティングの作成-3"><a class="header" href="#ルーティングの作成-3">ルーティングの作成</a></h2>
<p>update のルーティングを追加．</p>
<p>GETの場合と同様にid指定する．<code>/hoge</code>に<code>PUT</code>でリクエストを送信した場合，<code>req.params.id</code>は<code>hoge</code>になる．</p>
<pre><code class="language-js">// routes/tweet.route.js

import express from 'express';
import { readAllTweetData, readOneTweetData, createTweetData, editTweetData } from '../controllers/tweet.controller.js';

export const tweetRouter = express.Router();

tweetRouter.get('/', (req, res) =&gt; readAllTweetData(req, res));
tweetRouter.get('/:id', (req, res) =&gt; readOneTweetData(req, res));
tweetRouter.post('/', (req, res) =&gt; createTweetData(req, res));
// ↓追加
tweetRouter.put('/:id', (req, res) =&gt; editTweetData(req, res));

</code></pre>
<h2 id="コントローラの作成-3"><a class="header" href="#コントローラの作成-3">コントローラの作成</a></h2>
<p>コントローラでは，リクエストから<code>更新対象のドキュメントのid</code>と<code>更新データ</code>の 2 つを受け取る．送信されたデータの中から，これら 2 つのデータを抽出し，サービスに渡す．</p>
<pre><code class="language-js">// controllers/tweet.controller.js

import { getAllTweetData, getOneTweetData, insertTweetData, updateTweetData } from '../services/tweet.service.js';

export const readAllTweetData = async (req, res, next) =&gt; {
  // 省略
};

export const readOneTweetData = async (req, res, next) =&gt; {
  // 省略
};

export const createTweetData = async (req, res, next) =&gt; {
  // 省略
};

// ↓追加
export const editTweetData = async (req, res, next) =&gt; {
  try {
    const { id } = req.params;
    const { tweet, user_id } = req.body;
    if (!(id &amp;&amp; tweet &amp;&amp; user_id)) {
      throw new Error('something is blank');
    }
    const result = await updateTweetData({
      id: id,
      data: { tweet: tweet, user_id: user_id },
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: 'Succesfully edit Tweet Data!',
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの作成-3"><a class="header" href="#サービスの作成-3">サービスの作成</a></h2>
<p>送信されたデータを渡すのみなのでこれまでの処理と同様．</p>
<pre><code class="language-js">// services/tweet.service.js

import { findAll, find, store, update } from '../repositories/tweet.repository.js';

export const getAllTweetData = async () =&gt; {
  // 省略
};

export const getOneTweetData = async ({ id }) =&gt; {
  // 省略
};

export const insertTweetData = async ({ data }) =&gt; {
  // 省略
};

export const updateTweetData = async ({ id, data }) =&gt; {
  try {
    return await update({ id, data });
  } catch (e) {
    throw Error('Error while updating Tweet Data');
  }
};

</code></pre>
<h2 id="リポジトリの作成-3"><a class="header" href="#リポジトリの作成-3">リポジトリの作成</a></h2>
<p>リポジトリでは，受け取ったデータで DB を更新する．<code>deadline</code>を Firestore の形式に変換し，同時に<code>updated_at</code>に実行日時を設定して送信する．</p>
<p>collection 名と document 名を指定して<code>update()</code>でデータを更新できる．実行完了後には，更新ドキュメントの id と更新データを返す．</p>
<pre><code class="language-js">// repositories/tweet.repository.js

import admin from '../model/firebase.js';
const db = admin.firestore();

export const findAll = async () =&gt; {
  // 省略
};

export const find = async ({ id }) =&gt; {
  // 省略
};

export const store = async ({ data }) =&gt; {
  // 省略
}

// ↓追加
export const update = async ({ id, data }) =&gt; {
  const updateData = {
    ...data,
    updated_at: admin.firestore.Timestamp.now(),
  };
  const ref = await db.collection('tweet').doc(id).update(updateData);
  return {
    id: id,
    data: updateData,
  };
};

</code></pre>
<h2 id="動作確認更新"><a class="header" href="#動作確認更新">動作確認（更新）</a></h2>
<p>動作確認する．document は既存のデータから適当に指定する．Read の処理結果などから存在する document 名 を確認しておこう．</p>
<p>コンソール画面 or 前項の Read 処理でデータを確認し，データが更新されていれば OK！</p>
<pre><code class="language-bash">$ curl -X PUT -H &quot;Content-Type: application/json&quot; -d '{&quot;tweet&quot;:&quot;Nest.js&quot;,&quot;user_id&quot;:2}' localhost:3001/tweet/1JXLilqdOqU7rCrwjEpA

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;id&quot;: &quot;1JXLilqdOqU7rCrwjEpA&quot;,
    &quot;data&quot;: {
      &quot;tweet&quot;: &quot;Nest.js&quot;,
      &quot;user_id&quot;: 2,
      &quot;updated_at&quot;: {
        &quot;_seconds&quot;: 1627610411,
        &quot;_nanoseconds&quot;: 470000000
      }
    }
  },
  &quot;message&quot;: &quot;Succesfully edit Tweet Data!&quot;
}


</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="delete-の処理"><a class="header" href="#delete-の処理">Delete の処理</a></h1>
<h2 id="データ削除の処理"><a class="header" href="#データ削除の処理">データ削除の処理</a></h2>
<p>id を指定して該当するデータを DB から削除する．コレクション名とドキュメント id がわかっていればOK．</p>
<h2 id="ルーティングの作成-4"><a class="header" href="#ルーティングの作成-4">ルーティングの作成</a></h2>
<p>削除のルーティングを追加．更新の場合と同様にパラメータを受け取る．</p>
<pre><code class="language-js">// routes/tweet.route.js

import express from 'express';
import { readAllTweetData, readOneTweetData, createTweetData, editTweetData, deleteTweetData } from '../controllers/tweet.controller.js';

export const tweetRouter = express.Router();

tweetRouter.get('/', (req, res) =&gt; readAllTweetData(req, res));
tweetRouter.get('/:id', (req, res) =&gt; readOneTweetData(req, res));
tweetRouter.post('/', (req, res) =&gt; createTweetData(req, res));
tweetRouter.put('/:id', (req, res) =&gt; editTweetData(req, res));
// ↓追加
tweetRouter.delete('/:id', (req, res) =&gt; deleteTweetData(req, res));

</code></pre>
<h2 id="コントローラの作成-4"><a class="header" href="#コントローラの作成-4">コントローラの作成</a></h2>
<p>コントローラでは document 名（id）を受け取り，サービスの処理を実行する．</p>
<pre><code class="language-js">// controllers/tweet.controller.js

import { getAllTweetData, getOneTweetData, insertTweetData, updateTweetData, destroyTweetData } from '../services/tweet.service.js';

export const readAllTweetData = async (req, res, next) =&gt; {
  // 省略
};

export const readOneTweetData = async (req, res, next) =&gt; {
  // 省略
};

export const createTweetData = async (req, res, next) =&gt; {
  // 省略
};

export const editTweetData = async (req, res, next) =&gt; {
  // 省略
};

// ↓追加
export const deleteTweetData = async (req, res, next) =&gt; {
  try {
    const { id } = req.params;
    if (!id) {
      throw new Error('something is blank');
    }
    const result = await destroyTweetData({
      id: id,
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: 'Succesfully delete Tweet Data!',
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの作成-4"><a class="header" href="#サービスの作成-4">サービスの作成</a></h2>
<p>サービスではid指定してリポジトリで定義した関数を実行する．</p>
<pre><code class="language-js">// services/tweet.service.js

import { findAll, find, store, update, destroy } from '../repositories/tweet.repository.js';

export const getAllTweetData = async () =&gt; {
  // 省略
};

export const getOneTweetData = async ({ id }) =&gt; {
  // 省略
};

export const insertTweetData = async ({ data }) =&gt; {
  // 省略
};

export const updateTweetData = async ({ id, data }) =&gt; {
  // 省略
};

// ↓追加
export const destroyTweetData = async ({ id }) =&gt; {
  try {
    return await destroy({ id: id, });
  } catch (e) {
    throw Error('Error while deleting Tweet Data');
  }
};

</code></pre>
<h2 id="リポジトリの作成-4"><a class="header" href="#リポジトリの作成-4">リポジトリの作成</a></h2>
<p>リポジトリでは DB からデータを削除する．collection 名と document 名があればデータを指定して削除することができる．</p>
<pre><code class="language-js">// repositories/tweet.repository.js

import admin from '../model/firebase.js';
const db = admin.firestore();

export const findAll = async () =&gt; {
  // 省略
};

export const find = async ({ id }) =&gt; {
  // 省略
};

export const store = async ({ data }) =&gt; {
  // 省略
}

export const update = async ({ id, data }) =&gt; {
  // 省略
};

// ↓追加
export const destroy = async ({ id }) =&gt; {
  try {
    const ref = await db.collection('tweet').doc(id).delete();
    return { id: id, };
  } catch (e) {
    throw Error('Error while deleting Tweet Data');
  }
};
</code></pre>
<h2 id="動作確認削除"><a class="header" href="#動作確認削除">動作確認（削除）</a></h2>
<p>動作確認する．document 名 は既存のデータから適当に指定する．</p>
<p>コンソール画面 or 前項の Read 処理でデータを確認し，データが削除されていれば OK！</p>
<pre><code class="language-bash">$ curl -X DELETE localhost:3001/tweet/TPev9ejBQd7WkxWRuNKk

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;id&quot;: &quot;TPev9ejBQd7WkxWRuNKk&quot;
  },
  &quot;message&quot;: &quot;Succesfully delete Tweet Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="まとめ-1"><a class="header" href="#まとめ-1">まとめ</a></h1>
<p>今回は Node.js におけるデータの永続化を扱った．DB は Firestore を用いたが，他の DB でも処理の手順は大凡同様である．</p>
<p>今回はリポジトリパターンの実装で DB 関連の処理を別のレイヤーに切り出した．このようにすることで，DB 変更時にもコードの修正を該当レイヤーのみに閉じ込めることができる．</p>
<p>今回は以上である( `･ω･´)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="day03"><a class="header" href="#day03">Day03</a></h1>
<h2 id="今回のゴール-2"><a class="header" href="#今回のゴール-2">今回のゴール</a></h2>
<ul>
<li>React の基本的な処理を知り，実装を行う．</li>
<li>コンポーネントの組み合わせやデータの受け渡しを理解する．</li>
<li>外部との通信を実装し，データの扱い方や注意点を理解する．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="react-とは"><a class="header" href="#react-とは">React とは</a></h1>
<ul>
<li>ユーザインターフェース構築のための JavaScript ライブラリ</li>
</ul>
<h2 id="宣言的な-view"><a class="header" href="#宣言的な-view">宣言的な View</a></h2>
<ul>
<li>React は、インタラクティブなユーザインターフェイスの作成にともなう苦痛を取り除きます．アプリケーションの各状態に対応するシンプルな View を設計するだけで，React はデータの変更を検知し，関連するコンポーネントだけを効率的に更新，描画します．</li>
<li>宣言的な View を用いてアプリケーションを構築することで，コードはより見通しが立ちやすく，デバッグのしやすいものになります．</li>
</ul>
<h2 id="コンポーネントベース"><a class="header" href="#コンポーネントベース">コンポーネントベース</a></h2>
<ul>
<li>自分自身の状態を管理するカプセル化されたコンポーネントをまず作成し，これらを組み合わせることで複雑なユーザインターフェイスを構築します．</li>
<li>コンポーネントのロジックは，Template ではなく JavaScript そのもので書くことができるので，様々なデータをアプリケーション内で簡単に取り回すことができ，かつ DOM に状態を持たせないようにすることができます．</li>
</ul>
<h2 id="一度学習すればどこでも使える"><a class="header" href="#一度学習すればどこでも使える">一度学習すれば、どこでも使える</a></h2>
<ul>
<li>React と組み合わせて使用する技術に制限はありません．React を使って新しい機能を追加する際に，既存のソースコードを書き換える必要はありません．</li>
<li>React は Node を使ったサーバー上でもレンダーできますし，React Native を使うことでモバイルアプリケーションの中でも動きます．</li>
</ul>
<h2 id="で結局なんなのじゃ"><a class="header" href="#で結局なんなのじゃ">で，結局なんなのじゃ？</a></h2>
<ul>
<li>描画などの面倒な処理をいい感じにやってくれる．</li>
<li>画面に表示したいパーツ（コンポーネント）ごとに記述するので他の部分に影響しづらく，使い回しが効く．</li>
<li>ライブラリが充実しているのでだいたいのことはわりと簡単にできる．</li>
</ul>
<h2 id="今回作成するアプリケーション"><a class="header" href="#今回作成するアプリケーション">今回作成するアプリケーション</a></h2>
<ul>
<li>オススメ本を表示する SPA．</li>
<li>ページごとにカテゴリ別の本が一覧で表示される．</li>
<li>本のデータ Google books API から読み込んで表示する．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="アプリケーション実装の準備"><a class="header" href="#アプリケーション実装の準備">アプリケーション実装の準備</a></h1>
<h2 id="必要なツールのバージョン確認"><a class="header" href="#必要なツールのバージョン確認">必要なツールのバージョン確認</a></h2>
<ul>
<li>Node.js と npm が必要なので，以下のコマンドで状況を確認する．</li>
<li>バージョンが表示されれば OK．</li>
</ul>
<pre><code class="language-bash">$ node -v
v16.13.0
$ npm -v
8.1.0

</code></pre>
<h2 id="プロジェクトの作成"><a class="header" href="#プロジェクトの作成">プロジェクトの作成</a></h2>
<ul>
<li>React はプロジェクト単位でアプリケーションを開発する．</li>
<li>専用のコマンドが用意されているので，以下のようにプロジェクトを作成する．</li>
<li><code>npx</code> を使用すると，インストールしていないパッケージを実行できる．グローバルに残らないので，汚染の心配がない．</li>
<li>最後の <code>react-app</code> はプロジェクト名なので好きな名前で OK．</li>
</ul>
<pre><code class="language-bash">$ npx create-react-app react-app
</code></pre>
<p>※<code>npm</code> ではなく <code>npx</code> である点に注意！</p>
<p>いい感じにできたら，以下のコマンドでディレクトリに移動し，サーバを起動する．</p>
<pre><code class="language-bash">$ cd react-app
$ npm start
</code></pre>
<p>自動的にブラウザが立ち上がり，以下のような画面が表示されれば OK．</p>
<p><img src="day01/./img/firstview.png" alt="初期画面の画像" /></p>
<p>サーバはターミナル上で <code>control + c</code> すると停止できる．</p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>React の開発手順について</p>
<ul>
<li><code>npm start</code> を実行した状態でファイルを編集すると自動的にコンパイルが行われ，最新の状態がブラウザ画面に反映される．</li>
<li><code>npm start</code> 実行 -&gt; vs code でコード編集 -&gt; ブラウザで動作確認 の繰り返し．</li>
<li>ライブラリ追加時などはサーバを再起動しないと反映されないため．動作しない場合は <code>control + c</code> して再度 <code>npm start</code> でサーバを起動する．</li>
</ul>
</blockquote>
<h2 id="react-の大まかな仕組み"><a class="header" href="#react-の大まかな仕組み">React の大まかな仕組み</a></h2>
<ul>
<li>アプリケーションは全て <code>public/index.html</code> 上で実行される．</li>
<li>実行時には <code>src/index.js</code> が実行され，<code>App</code> コンポーネントが <code>index.html</code> 上にマウントされる．</li>
<li>実際に画面に表示されるのは <code>App.js</code> 内に記述された内容となる．</li>
<li>この <code>App.js</code> から様々なコンポーネントを読み込むことでアプリケーションが動作する．</li>
</ul>
<h2 id="メイン画面の編集と不要なファイルの削除"><a class="header" href="#メイン画面の編集と不要なファイルの削除">メイン画面の編集と不要なファイルの削除</a></h2>
<p>メインの画面は <code>App.js</code> であり，このファイルが <code>index.html</code> の <code>id=root</code> に描画される．</p>
<p>初期状態では <code>App.js</code> に不要な記述が含まれているため削除する．合わせて使用しないファイルも削除する．</p>
<p><code>App.js</code> のファイル名を <code>App.jsx</code> に変更し，内容を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>以下のファイルを削除する．</p>
<ul>
<li><code>src/App.css</code></li>
<li><code>src/App.test.js</code></li>
<li><code>src/logo.svg</code></li>
</ul>
<p>また，<code>index.js</code> の内容を以下のように編集する．</p>
<pre><code class="language-js">// index.js

import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
import App from &quot;./App&quot;;
import reportWebVitals from &quot;./reportWebVitals&quot;;

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById(&quot;root&quot;)
);

reportWebVitals();
</code></pre>
<p>以下のコマンドで開発サーバを起動する．</p>
<pre><code class="language-bash">$ npm start
</code></pre>
<p>ブラウザ画面を確認すると以下のようになっている．
<img src="day01/./img/mainview01.png" alt="メイン画面1" /></p>
<blockquote>
<p>【補足】js と jsx</p>
<ul>
<li>js：Javascript のファイル．</li>
<li>jsx：React 要素を生成する Javascript の拡張．React ではこちらを使うとたくさんいいことがある．</li>
</ul>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="コンポーネント"><a class="header" href="#コンポーネント">コンポーネント</a></h1>
<p>ここから，実際にコンポーネントを実装してみる．</p>
<p>まずは必要なファイルを準備しよう．</p>
<ul>
<li><code>src</code> ディレクトリに <code>components</code> ディレクトリを作成する．</li>
<li><code>components</code> ディレクトリ内に <code>Booklist.jsx</code> を作成する．</li>
<li><code>Booklist.jsx</code> に以下の内容を記述する．</li>
</ul>
<pre><code class="language-jsx">// Booklist.jsx

export const Booklist = (props) =&gt; {
  return (
    &lt;&gt;
      &lt;p&gt;this is book list component&lt;/p&gt;
    &lt;/&gt;
  );
};
</code></pre>
<blockquote>
<p>【解説】コンポーネントの作成</p>
<ul>
<li>コンポーネントには「class コンポーネント」と「関数コンポーネント」の 2 種類が存在する．</li>
<li>class コンポーネントは「状態を持つことができる（ステートフル）」という特徴があるが，関数コンポーネントでは「状態を持つことができない（ステートレス）」．</li>
<li>しかし，関数コンポーネントでも「React hooks」という技術を使うことで同様の振る舞いを実現することができる．</li>
<li>「state」というのはコンポーネント自体が持つ値であり，他にコンポーネントが外から受け取る「props」が存在する．</li>
<li>コンポーネント作成の際には，できるだけ state を持たないよう設計すると動作確認が楽になるだけでなく，バグの生まれる可能性も低減できる．</li>
<li>そのため，本記事ではすべて関数コンポーネントを使用してアプリケーションを構築し，必要に応じて「React hooks」を使用して状態を管理する．</li>
</ul>
</blockquote>
<h2 id="コンポーネントの構造"><a class="header" href="#コンポーネントの構造">コンポーネントの構造</a></h2>
<ul>
<li>関数 <code>Booklist</code> は呼び出し元のコンポーネントから<code>props</code>を受け取り，html 要素を出力する．</li>
<li><code>export const Booklist = ...</code> とすることで，他のコンポーネントから <code>import { Booklist } ...</code> のように記述して呼び出せるようにしている．</li>
</ul>
<h2 id="コンポーネントの呼び出し1"><a class="header" href="#コンポーネントの呼び出し1">コンポーネントの呼び出し（1）</a></h2>
<p><code>Booklist</code> コンポーネントを作成したので，<code>App</code> コンポーネントから呼び出してみる．</p>
<p><code>App.jsx</code> を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

// 🔽 追加（App.jsx 内で使用するためにコンポーネントを呼び出す）
import { Booklist } from &quot;./components/Booklist&quot;;

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist /&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>ブラウザで表示を確認すると以下のようになっている．</p>
<p><img src="day01/./img/mainview02.png" alt="メイン画面2" /></p>
<p>また，検証画面を確認すると，以下のように Booklist コンポーネントが読み込まれていることがわかる．</p>
<p><img src="day01/./img/elements01.png" alt="検証画面1" /></p>
<h2 id="コンポーネントの呼び出し2"><a class="header" href="#コンポーネントの呼び出し2">コンポーネントの呼び出し（2）</a></h2>
<p>呼び出すコンポーネントを 2 つにしてみる．</p>
<p><code>App.jsx</code> を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;

const App = () =&gt; {
  return (
    // 🔽 編集
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist /&gt;
      &lt;Booklist /&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>ブラウザ画面で，<code>Booklist</code> コンポーネントが 2 つ表示されていることを確認しよう．</p>
<p>このように，作成したコンポーネントは複数使用することもできる．</p>
<p><img src="day01/./img/mainview03.png" alt="メイン画面3" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="props-の活用"><a class="header" href="#props-の活用">props の活用</a></h1>
<p><code>props</code> は呼び出し元のコンポーネント（親コンポーネント）から呼び出されたコンポーネント（子コンポーネント）に渡されるデータの塊である．</p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>React のコンポーネントは「関数」であり，入力と出力がある．「入力」に当たるのがこの <code>props</code> である．</p>
</blockquote>
<h2 id="props-でデータを渡す"><a class="header" href="#props-でデータを渡す"><code>props</code> でデータを渡す</a></h2>
<p>実際に <code>App</code> コンポーネントから <code>Booklist</code> コンポーネントに文字列のデータを渡してみよう．</p>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    // 🔽 編集（コンポーネントに props を設定）
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist language={languages[0]} /&gt;
      &lt;Booklist /&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>ここでは，「<code>App</code> コンポーネントから <code>Booklist</code> コンポーネントに」「<code>language</code> という名前で」「<code>languages[0]</code> の値」を渡している．</p>
<p>タグ内に変数を入れるときは <code>{}</code> を使用する．</p>
<h2 id="props-でデータを受け取る"><a class="header" href="#props-でデータを受け取る"><code>props</code> でデータを受け取る</a></h2>
<p>続いて，値を渡される <code>Booklist.jsx</code> を以下のように編集する．</p>
<pre><code class="language-jsx">// Booklist.jsx

export const Booklist = ({ language }) =&gt; {
  return (
    &lt;&gt;
      &lt;p&gt;this is {language} list component&lt;/p&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>ブラウザで画面を確認すると以下のような状態になる．</p>
<p>1 つめのコンポーネントは <code>React</code> の文字列が追加されているが，2 つめのコンポーネントには追加されていない．なぜだろうか．</p>
<p><img src="day01/./img/mainview04.png" alt="メイン画面4" /></p>
<p>1 つめのコンポーネントには <code>App.jsx</code> で <code>language={languages[0]}</code> が記述されているが，2 つめでは記述されていない．そのため，2 つめのコンポーネントでは <code>props</code> が空の状態となっており表示が追加されない．</p>
<h2 id="追加"><a class="header" href="#追加">追加！</a></h2>
<p>2 つめのコンポーネントにもデータを渡すには次のように <code>App.jsx</code> を編集する．</p>
<p>（ついでにコンポーネントを追加！）</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    // 🔽 編集（コンポーネントに props を設定）
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist language={languages[0]} /&gt;
      &lt;Booklist language={languages[1]} /&gt;
      &lt;Booklist language={languages[2]} /&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>こうなる！</p>
<p><img src="day01/./img/mainview05.png" alt="メイン画面5" /></p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>このように，関数コンポーネントは <code>props</code> を受け取り，要素を返す関数となる．実装するときは「何を入力して」「何を出力するのか」を意識すると（多分）混乱せずすすめることができる．</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="router-機能"><a class="header" href="#router-機能">router 機能</a></h1>
<p>実際の web アプリケーションでは，処理ごとにページを分けて行いたい場合が多い．</p>
<p>ここまでの実装では，1 つのページに全てのコンポーネントを表示していたが，本項ではコンポーネントを別ページで表現する．そのままの記述ではページ遷移が行えないので，新しく <code>react-router</code> のライブラリをインストールする．</p>
<h2 id="react-router-のインストール"><a class="header" href="#react-router-のインストール"><code>react-router</code> のインストール</a></h2>
<p>ターミナルで<strong>作業ディレクトリにいることを確認</strong>し，下記コマンドを実行する．</p>
<pre><code class="language-bash">$ npm install react-router-dom
</code></pre>
<blockquote>
<p>【解説】ルーティング</p>
<ul>
<li>通常，React で web アプリケーションを実装すると，コンポーネントが切り替わっても URL は変化しない．</li>
<li>この 2 つを関連づけて，URL からアプリ内の特定のコンポーネントにアクセスできるようにしたり，逆にアプリ内での状態変化を URL に反映させたりすることをルーティングと呼ぶ．</li>
<li>ルーティングしておくと，ブラウザの戻るボタンで戻ったり，URL を打って特定のページに直接アクセスできたりするのでいい感じになる．</li>
</ul>
</blockquote>
<blockquote>
<p><strong>【注意】</strong></p>
<p><code>react-router</code> はバージョンが 5 から 6 にアップデートされたタイミングで記述方法が変更された部分がある．ドキュメントはバージョン 6 のものを確認すること．</p>
</blockquote>
<h2 id="ルーティングの定義"><a class="header" href="#ルーティングの定義">ルーティングの定義</a></h2>
<p><code>react-router</code>の機能を用いてルーティングを実装する．</p>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

import Booklist from &quot;./components/Booklist&quot;;
// 🔽 追加
import { BrowserRouter, Routes, Route } from &quot;react-router-dom&quot;;

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    // 🔽 編集
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/react&quot; element={&lt;Booklist language={languages[0]} /&gt;} /&gt;
        &lt;Route path=&quot;/vue&quot; element={&lt;Booklist language={languages[1]} /&gt;} /&gt;
        &lt;Route path=&quot;/angular&quot; element={&lt;Booklist language={languages[2]} /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;
</code></pre>
<ul>
<li><code>&lt;BrowserRouter&gt;</code> の中に <code>&lt;Routes&gt;</code> と <code>&lt;Route&gt;</code> を置き，<code>path</code> に対応させたい URL を，<code>element</code> に描画したいコンポーネントを渡す．</li>
<li><code>element</code> 内にコンポーネントを記述した場合でも <code>props</code> の渡し方は同様である．</li>
</ul>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>router 機能を使用したい場合は，コンポーネントを必ず <code>&lt;BrowserRouter&gt;</code> 内に配置すること．</p>
</blockquote>
<p>ブラウザで<code>localhost:3000/vue</code>などと URL を入力して表示を確認しよう．</p>
<p><img src="day01/./img/mainview06.png" alt="メイン画面6" /></p>
<h2 id="リンクを貼る"><a class="header" href="#リンクを貼る">リンクを貼る</a></h2>
<ul>
<li>毎回 URL 入力はダルい．</li>
<li>せっかくルーティングを実装したので，リンクを張ってブラウザ上で移動できるようにしたい．</li>
<li><code>react-router</code> の <code>Link</code> 機能を使うと簡単にリンクを作成できる．</li>
</ul>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;
// 🔽 Link を追加
import { BrowserRouter, Routes, Route, Link } from &quot;react-router-dom&quot;;

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];

  return (
    // 🔽 編集
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/react&quot;&gt;React&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/vue&quot;&gt;Vue&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/angular&quot;&gt;Angular&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;hr /&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/react&quot; element={&lt;Booklist language={languages[0]} /&gt;} /&gt;
        &lt;Route path=&quot;/vue&quot; element={&lt;Booklist language={languages[1]} /&gt;} /&gt;
        &lt;Route path=&quot;/angular&quot; element={&lt;Booklist language={languages[2]} /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;
</code></pre>
<p><code>&lt;Link&gt;</code> タグの <code>to</code> 部分に移動したい URL を書いておくと，<code>&lt;a&gt;</code> タグのようにリンクしてくれる．</p>
<p>ブラウザ画面で移動できることを確認しよう．</p>
<p><img src="day01/./img/mainview07.png" alt="メイン画面7" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="子コンポーネントへの関数入力"><a class="header" href="#子コンポーネントへの関数入力">子コンポーネントへの関数入力</a></h1>
<p>ページごとにコンポーネントを表示できたので，それぞれのページでキーワードから本のデータを取得したい．</p>
<p>子コンポーネントで関数を定義してもよいが，今回は <code>App.jsx</code> で関数を定義して子コンポーネントに渡す（関数の渡し方の練習）．</p>
<h2 id="関数の定義を-props-の-1-つとして渡す"><a class="header" href="#関数の定義を-props-の-1-つとして渡す">関数の定義を <code>props</code> の 1 つとして渡す</a></h2>
<p><code>App.jsx</code> を以下のように編集する</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;
import { BrowserRouter, Routes, Route, Link } from &quot;react-router-dom&quot;;

const App = () =&gt; {
  // 🔽 関数を追加
  const getDataFromAPI = (keyword) =&gt; {
    return `${keyword} books`;
  };

  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    // 🔽 1つ目のコンポーネントに関数を渡す
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/react&quot;&gt;React&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/vue&quot;&gt;Vue&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/angular&quot;&gt;Angular&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;hr /&gt;
      &lt;Routes&gt;
        &lt;Route
          path=&quot;/react&quot;
          element={
            &lt;Booklist language={languages[0]} getData={getDataFromAPI} /&gt;
          }
        /&gt;
        &lt;Route path=&quot;/vue&quot; element={&lt;Booklist language={languages[1]} /&gt;} /&gt;
        &lt;Route path=&quot;/angular&quot; element={&lt;Booklist language={languages[2]} /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;
</code></pre>
<p>ここでは「<code>getData</code>」という名前で「keyword を入力すると <code>getDataFromApi(keyword)</code> を実行する関数」を「<code>Booklist</code> コンポーネント」に渡している．</p>
<h2 id="props-からの受け取りと関数の実行"><a class="header" href="#props-からの受け取りと関数の実行">props からの受け取りと関数の実行</a></h2>
<p>続いて，<code>Booklist</code> コンポーネントで関数を受け取って実行する．</p>
<p>子コンポーネントで，読み込み時に渡された関数を実行してその結果を要素に反映する．</p>
<pre><code class="language-jsx">// Booklist.jsx

// 🔽 propsを追加
export const Booklist = ({ language, getData }) =&gt; {
  // 🔽 関数を実行（`?` を使用することで，`getData` が存在する場合のみ関数を実行可能）
  const result = getData?.(language);

  return (
    &lt;&gt;
      &lt;p&gt;this is {result} list component&lt;/p&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>ブラウザで確認すると「react books」のように表示がされていることがわかる．<code>Vue</code> と <code>Angular</code> の部分は関数を渡していないので表示がされない状態で OK．</p>
<p><img src="day01/./img/mainview08.png" alt="メイン画面8" /></p>
<p>ここまでうまく行ったら，<code>App.jsx</code> 内の <code>&lt;Route&gt;</code> 要素残り 2 つも同様に追記しよう．</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;
import { BrowserRouter, Route, Link } from &quot;react-router-dom&quot;;

const App = () =&gt; {
  const getDataFromAPI = (keyword) =&gt; {
    return `${keyword} books`;
  };

  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/react&quot;&gt;React&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/vue&quot;&gt;Vue&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/angular&quot;&gt;Angular&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;hr /&gt;
      &lt;Routes&gt;
        &lt;Route
          path=&quot;/react&quot;
          element={
            &lt;Booklist language={languages[0]} getData={getDataFromAPI} /&gt;
          }
        /&gt;
        &lt;Route
          path=&quot;/vue&quot;
          element={
            &lt;Booklist language={languages[1]} getData={getDataFromAPI} /&gt;
          }
        /&gt;
        &lt;Route
          path=&quot;/angular&quot;
          element={
            &lt;Booklist language={languages[2]} getData={getDataFromAPI} /&gt;
          }
        /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;
</code></pre>
<p>ブラウザで操作し，うまくいけば OK．これで親コンポーネントで定義した関数を子コンポーネントに渡すことができた．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http-リクエストの実装"><a class="header" href="#http-リクエストの実装">http リクエストの実装</a></h1>
<ul>
<li>子コンポーネントに関数が渡せたが，現状では入力値に文字列を追加して出力するだけの関数である．</li>
<li>そこで，指定したキーワードで Google books API からデータを取得する処理に変更する．</li>
<li>http リクエストには<code>axios</code>を使用する．</li>
</ul>
<h2 id="axios-ライブラリのインストール"><a class="header" href="#axios-ライブラリのインストール">axios ライブラリのインストール</a></h2>
<p>下記コマンドでインストール．</p>
<pre><code class="language-bash">$ npm install axios
</code></pre>
<p>エラーがでなければ OK．</p>
<h2 id="リクエスト関数を実装"><a class="header" href="#リクエスト関数を実装">リクエスト関数を実装</a></h2>
<p><code>App.jsx</code> の <code>getDataFromAPI</code> 関数を編集する．</p>
<pre><code class="language-jsx">// App.jsx

// 🔽 追加
import axios from &quot;axios&quot;;

// ...省略

// 🔽 getDataFromAPI 関数の内容を編集
const getDataFromAPI = async (keyword) =&gt; {
  const requestUrl = &quot;https://www.googleapis.com/books/v1/volumes?q=intitle:&quot;;
  const result = await axios.get(`${requestUrl}${keyword}`);
  return result;
};

// ...省略
</code></pre>
<p>※この記述だけでは動きません！！</p>
<h2 id="コンポーネントで関数を実行するusestate-useeffect"><a class="header" href="#コンポーネントで関数を実行するusestate-useeffect">コンポーネントで関数を実行する（useState, useEffect）</a></h2>
<p>子コンポーネントで <code>getDataFromAPI</code> 関数を実行したいが，以下 2 つの問題がある．</p>
<ul>
<li>子コンポーネントは関数であるため，取得したデータを保持できない．</li>
<li>データ更新時にレンダリングが再実行されるため，API リクエストが無限ループになる．</li>
</ul>
<p>前者の問題には <code>useState</code>，後者の問題には <code>useEffect</code> という機能を使うことで対処できる．</p>
<p>（<code>useState</code> と <code>useEffect</code> は React の標準の機能なのでインストールなどの作業は必要ない）</p>
<p><code>Booklist.jsx</code>を下記のように編集する．</p>
<pre><code class="language-jsx">// Booklist.jsx

// 🔽 追加
import { useState, useEffect } from &quot;react&quot;;

export const Booklist = ({ language, getData }) =&gt; {
  // 🔽 ここから追加
  const [bookData, setBookData] = useState(null);

  useEffect(() =&gt; {
    const result = getData?.(language).then((response) =&gt;
      setBookData(response)
    );
  }, [language, getData]);

  // 🔼 ここまで追加

  return (
    &lt;&gt;
      &lt;p&gt;this is {JSON.stringify(bookData)} list component&lt;/p&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>ブラウザで確認すると，以下のように取得したデータが文字列で表示される．</p>
<p><img src="day01/./img/mainview09.png" alt="メイン画面9" /></p>
<h2 id="解説usestate"><a class="header" href="#解説usestate">【解説】useState</a></h2>
<ul>
<li>useState は関数コンポーネントが値（今回は API から取得したデータ）を保持するための機能．</li>
<li><code>const [bookData, setBookData] = useState(null);</code> の
<ul>
<li><code>bookData</code> がデータを保持するための変数名．</li>
<li><code>setBookData</code> がデータを更新するための関数．</li>
<li><code>useState(null)</code> の <code>null</code> が <code>bookData</code> の初期値．</li>
</ul>
</li>
<li><code>setBookData(最新の値)</code> のように記述することで， <code>bookData</code> の値が最新の値に更新される．</li>
<li><code>bookData</code> に保存した内容を表示したいときなどは通常の変数のように扱えば OK．</li>
</ul>
<h2 id="解説useeffect"><a class="header" href="#解説useeffect">【解説】useEffect</a></h2>
<ul>
<li>関数外の副作用（外部からのデータ取得や DOM の更新など）を扱うための機能．</li>
<li>React では，コンポーネント内でデータの更新があると再レンダリングされるため，API からデータを取得すると毎回レンダリングが発生して無限ループとなってしまう．</li>
<li>useEffect はレンダリングを制限し，特定の値が更新されたときのみ処理が実行されるようにしてくれる機能．</li>
<li>書式は以下のような感じ．</li>
</ul>
<pre><code class="language-jsx">useEffect(() =&gt; {
  実行したい処理
}, [ここに書いた値（今回は`language`と`getData`）が更新されたときのみ，上の{}内が実行される．ここに値を書くときは配列で書く]);
</code></pre>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p><code>useState</code>と<code>useEffect</code>以外にも hooks には便利な機能が存在する．</p>
<p>まずはこの 2 つを使うことで多くの処理を実装可能であるため，まずはこの 2 つを扱えるようになろう．</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="表示の調整"><a class="header" href="#表示の調整">表示の調整</a></h1>
<p>現状では取得したデータを全て文字列で表示しているだけなので，書籍のタイトルがリスト表示されるよう整える．</p>
<p>booksData から必要なデータを取り出して <code>map()</code> 関数で <code>&lt;li&gt;</code> タグをつくる．</p>
<pre><code class="language-jsx">// Booklist.jsx

import { useState, useEffect } from &quot;react&quot;;

export const Booklist = ({ language, getData }) =&gt; {
  const [bookData, setBookData] = useState(null);

  useEffect(() =&gt; {
    const result = getData?.(language).then((response) =&gt;
      setBookData(response)
    );
  }, [language, getData]);

  // 🔽 データからタグを生成する処理を追加
  return (
    &lt;ul&gt;
      {bookData.data.items.map((x, index) =&gt; (
        &lt;li key={index}&gt;{x.volumeInfo.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<p>ブラウザで表示を確認するとエラーになる．</p>
<p><img src="day01/./img/mainview10.png" alt="メイン画面10" /></p>
<p>このエラーの原因は，まだ API からデータを取得していない状態でレンダリングしようとして <code>map()</code> 関数が実行されているためである．<code>map()</code> 関数は配列に対して処理を行う関数だが，配列のデータが存在しない状態で実行しようとしているためエラーとなる．</p>
<p>三項演算子を使用して，<code>bookData</code> の有無で表示を切り替えることで回避できる．</p>
<ul>
<li><code>bookData</code> が <code>null</code> の場合はローディング中のメッセージを表示．</li>
<li>データが取得できたらリスト表示に切り替え．</li>
</ul>
<pre><code class="language-jsx">// Booklist.jsx

import { useState, useEffect } from &quot;react&quot;;

export const Booklist = ({ language, getData }) =&gt; {
  const [bookData, setBookData] = useState(null);

  useEffect(() =&gt; {
    const result = getData?.(language).then((response) =&gt;
      setBookData(response)
    );
  }, [language, getData]);

  return (
    &lt;ul&gt;
      {bookData === null ? (
        &lt;p&gt;now loading...&lt;/p&gt;
      ) : (
        bookData.data.items.map((x, index) =&gt; (
          &lt;li key={index}&gt;{x.volumeInfo.title}&lt;/li&gt;
        ))
      )}
    &lt;/ul&gt;
  );
};
</code></pre>
<p>このように表示されれば OK！</p>
<p><img src="day01/./img/mainview11.png" alt="メイン画面11" /></p>
<p>リンククリックするとリストも切り替わる挙動になっている（はず）．</p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>このように，React ではデータの取得とレンダリングのタイミングなどでハマることが多い．</p>
<p>まずはエラーをよく読むことと，目的のデータが存在しているかどうか，どんな形のデータになっているのかを確認しながら進めると良い．</p>
</blockquote>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<p>上記の問題は optional chaining でも回避可能．</p>
<pre><code class="language-jsx">&lt;ul&gt;
  {bookData?.data.items.map((x, index) =&gt; (
    &lt;li key={index}&gt;{x.volumeInfo.title}&lt;/li&gt;
  ))}
&lt;/ul&gt;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="課題任意"><a class="header" href="#課題任意">課題（任意）</a></h1>
<ul>
<li>本のタイトル以外のデータ（著者や画像）の表示．</li>
<li>別の API を使用してデータをブラウザに表示．</li>
</ul>
<p>今回はここまで( `･ω･)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="day04"><a class="header" href="#day04">Day04</a></h1>
<h2 id="今回のゴール-3"><a class="header" href="#今回のゴール-3">今回のゴール</a></h2>
<ul>
<li>前回実装したサーバアプリケーションのクライアント側を実装する．</li>
<li>コンポーネントの扱いを復習する．</li>
<li>データ取得タイミングと使い分けのイメージを把握する．</li>
</ul>
<h2 id="アプリケーションの全体像-1"><a class="header" href="#アプリケーションの全体像-1">アプリケーションの全体像</a></h2>
<p>twitter みたいなアプリケーションのフロント側を実装する．</p>
<p>tweet の送信機能，一覧表示，個別表示を実装．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="サーバ側の準備"><a class="header" href="#サーバ側の準備">サーバ側の準備</a></h1>
<p>サーバ側の処理は前回までに実装した内容そのままで問題ないが，クライアントからアクセスする場合に一部追加が必要になる．</p>
<h2 id="cross-origin-resource-sharing"><a class="header" href="#cross-origin-resource-sharing">Cross-Origin Resource Sharing</a></h2>
<p>サーバ側の規定の動作として「異なるオリジンからのアクセスをブロックする」というものが存在する．</p>
<pre><code class="language-txt">https://www.emperor-crimson.com
  ^       ^
  |       |
scheme hostname


http://localhost:5000
  ^       ^       ^
  |       |       |
scheme hostname  port

</code></pre>
<blockquote>
<p><strong>Key Point</strong>💡</p>
<p>実際の運用でサーバとクライアントを分ける場合には「サーバ側でクライアントのオリジンからのアクセスを許可する実装」が必要となる．</p>
<p>API へのリクエストを開放する場合にはリクエスト元のホスト問わず許可し，自分のアプリケーションからのみリクエストする場合はクライアント側のホスト名を指定しておく，など．</p>
</blockquote>
<h2 id="実装"><a class="header" href="#実装">実装</a></h2>
<p>Node.js では Cross-Origin を設定するためのライブラリが存在するので，これを利用するのが楽．</p>
<p>以下のコマンドでインストールする．</p>
<pre><code class="language-bash">$ npm i cors
</code></pre>
<p><code>app.js</code>に以下のように追記する．</p>
<p>今回はとりあえずリクエスト元を問わず受け付ける指定にしている．</p>
<p>より詳しい設定はドキュメントを参照．API 毎にアクセスを許可したり拒否したりできる．</p>
<p><a href="https://github.com/expressjs/cors">https://github.com/expressjs/cors</a></p>
<pre><code class="language-js">import express from 'express';
// ↓ 追加
import cors from 'cors';

// 省略

const app = express();
// ↓ 1 行追加
app.use(cors());
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// 省略

</code></pre>
<p>クライアントからリクエストを受ける必要があるので，サーバ側のアプリケーションを立ち上げておこう．</p>
<pre><code class="language-bash">$ npm start
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="必要な画面の準備"><a class="header" href="#必要な画面の準備">必要な画面の準備</a></h1>
<h2 id="ルーティング"><a class="header" href="#ルーティング">ルーティング</a></h2>
<p>クライアント側で必要な画面とパスは以下のとおり．フロント側のルーティングなのでサーバ側と混同しないように注意．</p>
<table><thead><tr><th>パス</th><th>画面の概要</th></tr></thead><tbody>
<tr><td><code>/tweet/</code></td><td>tweet 一覧画面</td></tr>
<tr><td><code>/tweet/:id</code></td><td>tweet 1 件表示画面</td></tr>
<tr><td><code>/tweet/post</code></td><td>tweet 入力 &amp; 送信画面</td></tr>
</tbody></table>
<h2 id="必要なファイルの準備"><a class="header" href="#必要なファイルの準備">必要なファイルの準備</a></h2>
<ol>
<li><code>src</code>以下に<code>pages</code>フォルダを作成する．</li>
<li><code>pages</code>フォルダの中に下記のファイルを作成する．
<ul>
<li><code>TweetIndex.jsx</code></li>
<li><code>TweetFind.jsx</code></li>
<li><code>TweetPost.jsx</code></li>
</ul>
</li>
</ol>
<p>ディレクトリは任意の構造にできるが，「ページを表すコンポーネント」と「部品としてのコンポーネント」を分けておくと管理しやすい．</p>
<p>それぞれ以下のように内容を記述する．</p>
<pre><code class="language-js">// src/pages/TweetIndex.jsx

import React from &quot;react&quot;;

export const TweetIndex = () =&gt; {
  return (
    &lt;p&gt;tweet 一覧画面&lt;/p&gt;
  )
};

</code></pre>
<pre><code class="language-js">// src/pages/TweetFind.jsx

import React from &quot;react&quot;;

export const TweetFind = () =&gt; {
  return (
    &lt;p&gt;tweet 1 件表示画面&lt;/p&gt;
  )
};

</code></pre>
<pre><code class="language-js">// src/pages/TweetPost.jsx

import React from &quot;react&quot;;

export const TweetPost = () =&gt; {
  return (
    &lt;p&gt;tweet 入力送信画面&lt;/p&gt;
  )
};

</code></pre>
<p><code>App.jsx</code>を以下のように編集する．</p>
<p>（これまでのコードは適宜コメントアウトしておくこと）</p>
<pre><code class="language-js">// src/App.jsx

import React from &quot;react&quot;;
import { BrowserRouter, Route, Link, Switch } from &quot;react-router-dom&quot;;
import { TweetIndex } from &quot;./pages/TweetIndex&quot;;
import { TweetFind } from &quot;./pages/TweetFind&quot;;
import { TweetPost } from &quot;./pages/TweetPost&quot;;

const NotFound = () =&gt; {
  return (
    &lt;h2&gt;Not Found...&lt;/h2&gt;
  );
};

const App = () =&gt; {
  return (
    &lt;BrowserRouter&gt;
      &lt;h1&gt;Twitterのようなもの&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/tweet/&quot;&gt;tweet 一覧&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/tweet/post&quot;&gt;tweet 入力&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;hr /&gt;
      &lt;Switch&gt;
        &lt;Route exact path=&quot;/tweet/&quot;&gt;
          &lt;TweetIndex /&gt;
        &lt;/Route&gt;
        &lt;Route exact path=&quot;/tweet/post&quot;&gt;
          &lt;TweetPost /&gt;
        &lt;/Route&gt;
        &lt;Route path=&quot;/tweet/:id&quot;&gt;
          &lt;TweetFind /&gt;
        &lt;/Route&gt;
        &lt;Route&gt;
          &lt;NotFound /&gt;
        &lt;/Route&gt;
      &lt;/Switch&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;

</code></pre>
<h2 id="動作確認-6"><a class="header" href="#動作確認-6">動作確認</a></h2>
<p>一通り記述したら画面の表示を確認する．</p>
<pre><code class="language-bash">$ npm start
</code></pre>
<p>それぞれの画面が表示されればOK．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tweet-送信画面の作成"><a class="header" href="#tweet-送信画面の作成">tweet 送信画面の作成</a></h1>
<p>ブラウザ画面から tweet を送信できるように処理を追加する．</p>
<h2 id="form-を扱うライブラリの準備"><a class="header" href="#form-を扱うライブラリの準備">Form を扱うライブラリの準備</a></h2>
<p>前回の API と連携させるため，画面に入力したデータを POST で送信する必要がある（前回はターミナルでリクエストを送信していた）．</p>
<p>form を扱うのは面倒なのでライブラリを使用するのが得策．ちょうど<code>useState</code>や<code>useEffect</code>などの「Hooks」と合わせて使用できる「React Hook Form」が提供されている．</p>
<p><a href="https://react-hook-form.com/jp/">https://react-hook-form.com/jp/</a></p>
<p>下記コマンドでインストールする．</p>
<pre><code class="language-bash">$ npm i react-hook-form
</code></pre>
<p><code>TweetPost.jsx</code>を以下のように編集する．</p>
<p>まずは form の動きを確認する．</p>
<pre><code class="language-js">import React, { useState } from &quot;react&quot;;
import { useForm } from &quot;react-hook-form&quot;;
import axios from &quot;axios&quot;;

export const TweetPost = () =&gt; {
  const { register, handleSubmit } = useForm();

  const [formData, setFormData] = useState(null);

  const postFormData = async (postData) =&gt; {
    setFormData(JSON.stringify(postData));
  };

  return (
    &lt;form onSubmit={handleSubmit(postFormData)}&gt;
      &lt;input {...register(&quot;tweet&quot;)} placeholder=&quot;Tweet&quot; /&gt;
      &lt;input {...register(&quot;user_id&quot;)} placeholder=&quot;User_id&quot; type=&quot;number&quot; /&gt;
      &lt;p&gt;{formData}&lt;/p&gt;
      &lt;button type=&quot;submit&quot;&gt;送信&lt;/button&gt;
    &lt;/form&gt;
  )
};

</code></pre>
<h2 id="動作確認-7"><a class="header" href="#動作確認-7">動作確認</a></h2>
<p>コードを記述したら動作を確認する．</p>
<p>入力欄に適当な文字列を入力し，入力した値が下記のように表示されればOK．</p>
<pre><code class="language-txt">{&quot;tweet&quot;:&quot;test&quot;,&quot;user_id&quot;:&quot;4&quot;}
</code></pre>
<h2 id="post-送信処理の追加"><a class="header" href="#post-送信処理の追加">POST 送信処理の追加</a></h2>
<p>form の動きは確認できたので，サーバ側に入力内容を送信する．</p>
<p>POST で送信する場合は<code>axios.post()</code>を用いる．第 1 引数にリクエスト URL を，第 2 引数に送信するデータを入れる．</p>
<p><code>postFormData</code>関数を以下のように編集する．</p>
<pre><code class="language-js">const postFormData = async (postData) =&gt; {
  setFormData(JSON.stringify(postData));
  const result = await axios.post(&quot;http://localhost:3001/tweet&quot;, postData);
  console.log(result);
  return result;
};

</code></pre>
<h2 id="動作確認-8"><a class="header" href="#動作確認-8">動作確認</a></h2>
<blockquote>
<p>必ずサーバ側のアプリケーションを動作させてくこと！！</p>
</blockquote>
<p>先の動作確認と同様に，適当な文字列を入力欄に入力して送信する．</p>
<p>コンソールに以下のようなレスポンスが表示されればOK．</p>
<pre><code class="language-js">{
  &quot;data&quot;: {
    &quot;status&quot;: 200,
      &quot;result&quot;: {
      &quot;id&quot;: &quot;7IKHDJBdyUCwhVZ2wtsV&quot;,
        &quot;data&quot;: {
        &quot;tweet&quot;: &quot;test&quot;,
          &quot;user_id&quot;: &quot;4&quot;
      }
    },
    &quot;message&quot;: &quot;Succesfully post Tweet Data!&quot;
  },
  &quot;status&quot;: 200,
    &quot;statusText&quot;: &quot;OK&quot;,
      &quot;headers&quot;: {
    &quot;content-length&quot;: &quot;132&quot;,
      &quot;content-type&quot;: &quot;application/json; charset=utf-8&quot;
  },
  &quot;config&quot;: {
    &quot;url&quot;: &quot;http://localhost:3001/tweet&quot;,
      &quot;method&quot;: &quot;post&quot;,
        &quot;data&quot;: &quot;{\&quot;tweet\&quot;:\&quot;test\&quot;,\&quot;user_id\&quot;:\&quot;4\&quot;}&quot;,
          &quot;headers&quot;: {
      &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;,
        &quot;Content-Type&quot;: &quot;application/json;charset=utf-8&quot;
    },
    &quot;transformRequest&quot;: [
      null
    ],
      &quot;transformResponse&quot;: [
        null
      ],
        &quot;timeout&quot;: 0,
          &quot;xsrfCookieName&quot;: &quot;XSRF-TOKEN&quot;,
            &quot;xsrfHeaderName&quot;: &quot;X-XSRF-TOKEN&quot;,
              &quot;maxContentLength&quot;: -1,
                &quot;maxBodyLength&quot;: -1
  },
  &quot;request&quot;: { }
}

</code></pre>
<p>これでブラウザから tweet をサーバに送信する処理は完了．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tweet-一覧画面の作成"><a class="header" href="#tweet-一覧画面の作成">tweet 一覧画面の作成</a></h1>
<p>続いて一覧画面を作成する．</p>
<h2 id="ダミーデータの表示"><a class="header" href="#ダミーデータの表示">ダミーデータの表示</a></h2>
<p><code>TweetIndex.jsx</code>を以下のように編集する．</p>
<p>まずは適当なダミーデータを正しく画面に表示できることを確認する．ダミーデータを<code>useState</code>の変数に初期値として設定し，画面に表示する．</p>
<pre><code class="language-js">// src/pages/TweetIndex.jsx

import React, { useState } from &quot;react&quot;;

export const TweetIndex = () =&gt; {
  const dummyTweetList = [
    { id: &quot;qwerty&quot;, data: { tweet: &quot;test1&quot;, user_id: &quot;1&quot;, created_at: JSON.stringify(new Date()), } },
    { id: &quot;asdfgh&quot;, data: { tweet: &quot;test2&quot;, user_id: &quot;2&quot;, created_at: JSON.stringify(new Date()), } },
    { id: &quot;zxcvbn&quot;, data: { tweet: &quot;test3&quot;, user_id: &quot;3&quot;, created_at: JSON.stringify(new Date()), } },
  ];

  const [tweetList, setTweetList] = useState(dummyTweetList);

  return (
    &lt;ul&gt;
      {tweetList.map((x, i) =&gt; &lt;li key={i}&gt;{x.data.tweet} by {x.data.user_id} at {x.data.created_at}&lt;/li&gt;)}
    &lt;/ul&gt;
  )
};

</code></pre>
<h2 id="動作確認-9"><a class="header" href="#動作確認-9">動作確認</a></h2>
<p>一覧画面にアクセスし，dummy のデータが一覧で表示されればOK．</p>
<pre><code class="language-txt">test1 by 1 at &quot;2021-08-10T04:47:27.316Z&quot;
test2 by 2 at &quot;2021-08-10T04:47:27.316Z&quot;
test3 by 3 at &quot;2021-08-10T04:47:27.316Z&quot;
</code></pre>
<h2 id="データ取得処理の追加"><a class="header" href="#データ取得処理の追加">データ取得処理の追加</a></h2>
<p>API サーバから tweet のデータを取得する処理を追加する．</p>
<p>1 回め講義の Google books API データ取得時と同様に<code>useState</code>と<code>useEffect</code>を用いた実装としている．</p>
<pre><code class="language-js">// src/pages/TweetIndex.jsx

import React, { useState, useEffect } from &quot;react&quot;;
import axios from &quot;axios&quot;;

export const TweetIndex = () =&gt; {

  // 省略

  const [tweetList, setTweetList] = useState(null);

  useEffect(() =&gt; {
    const getAllTweet = async () =&gt; {
      const result = await axios.get(&quot;http://localhost:3001/tweet&quot;);
      setTweetList(result.data.result);
      return result;
    };
    getAllTweet();
  }, []);

  return (
    &lt;ul&gt;
      {tweetList?.map((x, i) =&gt; &lt;li key={i}&gt;{x.data.tweet} by {x.data.user_id} at {x.data.created_at}&lt;/li&gt;)}
    &lt;/ul&gt;
  )
};

</code></pre>
<h2 id="動作確認-10"><a class="header" href="#動作確認-10">動作確認</a></h2>
<blockquote>
<p>必ずサーバ側のアプリケーションを動作させてくこと！！</p>
</blockquote>
<p>ブラウザで動作を確認する．</p>
<p>一覧画面に Firestore に保存されているデータが表示されればOK．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="コンポーネントの最適化"><a class="header" href="#コンポーネントの最適化">コンポーネントの最適化</a></h1>
<p>各 tweet の内容はシンプルなのでこのままでも問題ないが，より複雑な情報を扱う場合には個別のコンポーネントに分けることが望ましい．</p>
<h2 id="必要なファイルの準備-1"><a class="header" href="#必要なファイルの準備-1">必要なファイルの準備</a></h2>
<p><code>src/components</code>フォルダの中に各 tweet を表示する<code>Tweet.jsx</code>を作成する．</p>
<p>以下の内容を記載する．</p>
<pre><code class="language-js">// src/components/Tweet.jsx

import React from &quot;react&quot;;

export const Tweet = () =&gt; {
  return (
    &lt;li&gt;
      &lt;p&gt;tweet by user_id at created_at&lt;/p&gt;
    &lt;/li&gt;
  )
};

</code></pre>
<h2 id="一覧画面の編集"><a class="header" href="#一覧画面の編集">一覧画面の編集</a></h2>
<p><code>TweetIndex.jsx</code>を以下のように編集する．</p>
<pre><code class="language-js">import React, { useState, useEffect } from &quot;react&quot;;
import axios from &quot;axios&quot;;
// ↓ 追加
import { Tweet } from &quot;../components/Tweet&quot;;

export const TweetIndex = () =&gt; {

  // 省略

  // ↓ 編集
  return (
    &lt;ul&gt;
      {tweetList?.map((x, i) =&gt; &lt;Tweet key={i} id={x.id} tweet={x.data.tweet} user_id={x.data.user_id} created_at={x.data.created_at} /&gt;)}
    &lt;/ul&gt;
  )
};

</code></pre>
<h2 id="個別ツイートコンポーネントの実装"><a class="header" href="#個別ツイートコンポーネントの実装">個別ツイートコンポーネントの実装</a></h2>
<p><code>Tweet.jsx</code>コンポーネントを以下のように編集する．</p>
<p>このコンポーネントは<code>key</code>，<code>id</code>，<code>tweet</code>，<code>user_id</code>，<code>created_at</code>の 5 つのパラメータを入力することとする．</p>
<pre><code class="language-js">// src/components/Tweet.jsx

import React from &quot;react&quot;;

export const Tweet = ({ key, id, tweet, user_id, created_at }) =&gt; {
  return (
    &lt;li key={key} id={id}&gt;&lt;p&gt;{tweet} by {user_id} at {created_at}&lt;/p&gt;&lt;/li&gt;
  )
};

</code></pre>
<h2 id="動作確認-11"><a class="header" href="#動作確認-11">動作確認</a></h2>
<p>これまでと同様に tweet の一覧が表示されればOK．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tweet-個別表示画面の作成"><a class="header" href="#tweet-個別表示画面の作成">tweet 個別表示画面の作成</a></h1>
<p>各 tweet の個別画面を実装する．一覧画面で各 tweet をクリックすると個別の画面を表示するようにしたい．</p>
<h2 id="tweet-コンポーネントの編集"><a class="header" href="#tweet-コンポーネントの編集">tweet コンポーネントの編集</a></h2>
<p><code>Tweet.jsx</code>コンポーネントを以下のように編集する．</p>
<p>日時表示部分にリンクを設定し，URL に id を追加している．</p>
<pre><code class="language-js">// src/components/Tweet.jsx

import React from &quot;react&quot;;
import { Link } from &quot;react-router-dom&quot;;

export const Tweet = ({ key, id, tweet, user_id, created_at }) =&gt; {
  return (
    &lt;li key={key} id={id}&gt;&lt;p&gt;{tweet} by {user_id} at &lt;Link to={`/tweet/${id}`}&gt;{created_at}&lt;/Link&gt;&lt;/p&gt;&lt;/li&gt;
  )
};

</code></pre>
<h2 id="個別-tweet-コンポーネントの実装"><a class="header" href="#個別-tweet-コンポーネントの実装">個別 tweet コンポーネントの実装</a></h2>
<p>個別表示用ページの<code>TweetFind.jsx</code>を以下のように編集する．</p>
<p><code>useParams</code>を用いることで，URL に付加された id を取得することができる．</p>
<p>この id を用いてサーバ側にリクエストを送信する（サーバ側では，前回の内容で id 指定して 1 件データ取得する処理を実装した）．</p>
<pre><code class="language-js">// src/pages/TweetFind.jsx

import React, { useState, useEffect } from &quot;react&quot;;
import { useParams } from &quot;react-router-dom&quot;
import axios from &quot;axios&quot;;

export const TweetFind = () =&gt; {
  const { id } = useParams();
  const [tweet, setTweet] = useState(null);

  useEffect(() =&gt; {
    const getOneTweet = async (id) =&gt; {
      const result = await axios.get(`http://localhost:3001/tweet/${id}`);
      setTweet(result.data.result);
      return result;
    };
    getOneTweet(id);
  }, []);

  return (
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;&lt;td&gt;DocumentId&lt;/td&gt;&lt;td&gt;{tweet?.id}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Tweet&lt;/td&gt;&lt;td&gt;{tweet?.data.tweet}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;User_id&lt;/td&gt;&lt;td&gt;{tweet?.data.user_id}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Created_at&lt;/td&gt;&lt;td&gt;{tweet?.data.created_at}&lt;/td&gt;&lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  )
};

</code></pre>
<h2 id="動作確認-12"><a class="header" href="#動作確認-12">動作確認</a></h2>
<p>一覧画面の作成日時部分のリンクから個別ページに遷移し，個別のデータが表示されればOK．</p>
<h2 id="補足"><a class="header" href="#補足">補足</a></h2>
<p>オブジェクトのプロパティにアクセスする場合，該当しないキーにアクセスすると<code>undefined</code>となる．そのため，更に下位のキーを指定するとエラーとなるため処理が止まってしまう．</p>
<p>このような場合，<code>?.</code>を使用するとエラーではなく<code>undefined</code>として処理することができる．</p>
<pre><code class="language-js">const someObject = {
  hoge: 1,
  fuga: 2,
  piyo: 3,
};

console.log(someObject.foo);
// undefined

console.log(someObject.foo.bar);
// Uncaught TypeError: Cannot read property 'bar' of undefined

console.log(someObject.foo?.bar);
// undefined

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="データ取得タイミングの最適化"><a class="header" href="#データ取得タイミングの最適化">データ取得タイミングの最適化</a></h1>
<p>ここまで，講義 1 回めで使用した<code>useEffect</code>を用いてデータを取得していたが，最新の情報を取得するには再度読み込みを行う必要があった．</p>
<p>しかし，頻繁に情報が更新されるアプリケーションの場合，ユーザの再読込をトリガにしたデータ取得は現実的ではない．</p>
<p>本項では，様々なデータ取得タイミングを解説し，本アプリケーションに適した処理を実装する．</p>
<h2 id="データ取得と反映方法の紹介"><a class="header" href="#データ取得と反映方法の紹介">データ取得と反映方法の紹介</a></h2>
<p>雑な紹介は以下のとおり．</p>
<table><thead><tr><th>名称</th><th>概要</th></tr></thead><tbody>
<tr><td>SSR</td><td>サーバ側で HTML を生成する方式．クライアント側で JS が実行されなくてもコンテンツが存在する状況となる．</td></tr>
<tr><td>SSG</td><td>サーバ上で，MD ファイルなどから HTML ファイルを生成し，クライアント側からは HTML ファイルを読むだけにする方式．サーバ上には静的な（static） HTML が置かれている状況となる．ソースデータが更新された場合は開発者側が再度ビルドを行う必要がある．</td></tr>
<tr><td>ISR</td><td>SSG を効率よく実現するための方法．指定時間毎に SSG のビルドを行うことができる．開発者が都度ビルドを行うことなく，アプリケーションの状態を最新に保つことができる．</td></tr>
<tr><td>CSR</td><td>クライアント側で動作する JS が HTML 要素を生成する方式．主にサーバから JSON 形式のデータを受け取り， JS が HTML 要素を構築して画面に表示される流れとなる．React では useEffect や axios を使用した一般的な実装．</td></tr>
<tr><td>SWR</td><td>CSR を効率よく実現するための方法．クライアント側で再読込を行わなくても，指定時間毎やユーザ操作のタイミングでデータ取得処理を動作させることができる．useSWR を使用して実装が可能．</td></tr>
</tbody></table>
<h2 id="使い分け-1"><a class="header" href="#使い分け-1">使い分け</a></h2>
<p>データを取得するタイミングによる．</p>
<p>クライアント側の状態をどの程度の頻度で最新に保つ必要があるのかにより，最適な実装は異なる．</p>
<p>いくつかの例を以下に示す．</p>
<table><thead><tr><th>状況</th><th>実装</th></tr></thead><tbody>
<tr><td>開発者の個人ブログ，ドキュメントなど．</td><td>SSG</td></tr>
<tr><td>ユーザ投稿型のブログなど．</td><td>SSG（ISR使用）</td></tr>
<tr><td>ユーザ短文投稿型の SNS など．</td><td>CSR（SWR使用）</td></tr>
</tbody></table>
<p>より厳密なリアルタイム性が求められる場合（ユーザ同士のチャットアプリケーションなど）にはサーバ側で web socket の実装などを行う必要がある．</p>
<h2 id="実装-1"><a class="header" href="#実装-1">実装</a></h2>
<p>今回のアプリケーションでは，すでに CSR にて実装を行っている．</p>
<p>tweet 一覧表示において，より柔軟なタイミングで最新のデータが取得できるよう SWR を用いた実装を追加で行う．</p>
<h2 id="swr-処理の実装"><a class="header" href="#swr-処理の実装">SWR 処理の実装</a></h2>
<p>SWR の機能はライブラリとして提供されている．</p>
<p>下記コマンドでインストールする．</p>
<pre><code class="language-bash">$ npm i swr
</code></pre>
<p><code>TweetIndex.jsx</code>を以下のように編集する．</p>
<p>データを取得するための<code>fetcher</code>関数を定義し，<code>useSWR</code>で「リクエスト先」と「データ取得関数」を指定する．</p>
<blockquote>
<p>解説</p>
<ul>
<li>取得したデータと失敗した場合のエラーはそれぞれ<code>data</code>と<code>error</code>に格納される．</li>
<li>データが取得できなかった場合やエラーが発生しない場合はそれぞれ<code>undefined</code>となるため，容易に条件分岐することができる．</li>
</ul>
</blockquote>
<pre><code class="language-js">// src/pages/TweetIndex.jsx

import React, { useState, useEffect } from &quot;react&quot;;
import axios from &quot;axios&quot;;
import { Tweet } from &quot;../components/Tweet&quot;;
import useSWR from &quot;swr&quot;

export const TweetIndex = () =&gt; {

  // 省略

  // ↓ 追加
  const fetcher = async (url) =&gt; (await axios.get(url)).data.result;

  // ↓ 追加
  const { data, error } = useSWR(&quot;http://localhost:3001/tweet&quot;, fetcher)

  // ↓ 追加
  return (
    &lt;ul&gt;
      {data?.map((x, i) =&gt; &lt;Tweet key={i} id={x.id} tweet={x.data.tweet} user_id={x.data.user_id} created_at={x.data.created_at} /&gt;)}
    &lt;/ul&gt;
  )
};

</code></pre>
<h2 id="動作確認-13"><a class="header" href="#動作確認-13">動作確認</a></h2>
<p>これまでと同様の動作になっていればOK．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="データ取得タイミングの調整"><a class="header" href="#データ取得タイミングの調整">データ取得タイミングの調整</a></h1>
<p>SWR を使用すると，様々なタイミングでデータ取得の処理を実行することができる．</p>
<h2 id="swr-のオプション設定"><a class="header" href="#swr-のオプション設定">SWR のオプション設定</a></h2>
<p>今回は以下の 2 パターンでデータを取得する処理を実装してみる．</p>
<ul>
<li>ユーザの操作によらず 5 秒毎にデータ取得．</li>
<li>ユーザがウインドウをアクティブにしたタイミングでデータ取得．</li>
</ul>
<p>その他のオプションはドキュメント参照．</p>
<p><a href="https://swr.vercel.app/docs/options">https://swr.vercel.app/docs/options</a></p>
<p><code>TweetIndex.jsx</code>を以下のように編集する．</p>
<pre><code class="language-js">// src/pages/TweetIndex.jsx

  // 省略

  const fetcher = async (url) =&gt; (await axios.get(url)).data.result;

  const options = {
    // 初期データ
    initialData: null,
    // pollingの期間（ミリ秒）
    refreshInterval: 5000,
    // windowのフォーカス時にRevalidateする
    revalidateOnFocus: true,
  }

  const { data, error } = useSWR(&quot;http://localhost:3001/tweet&quot;, fetcher, options)

  // 省略

</code></pre>
<h2 id="動作確認-14"><a class="header" href="#動作確認-14">動作確認</a></h2>
<p>タブを 2 つ用意し，両方とも実装中のアプリケーションを開く．片方は「 tweet 送信画面」もう片方は「一覧画面」を表示しておく．</p>
<p>送信画面側で tweet を送信し，一覧画面を操作しなくても自動的に表示されればOK．</p>
<p>なにもしなくてもデータ取って表示できる．すごい．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="まとめ-2"><a class="header" href="#まとめ-2">まとめ</a></h1>
<p>今回は twitter のようなアプリケーションのクライアント側を実装し，サーバ側と連携を行った．</p>
<p>クライアント側では，ユーザがどのようにアプリケーションを使用するかによって最適な実装が異なる．</p>
<p>フロントの技術として画面の見え方だけでなく，ユーザがストレスなくデータにアクセスできる環境を整備したり，必要なタイミングでデータの送受信ができるようにしたりなどの視点も大切である．</p>
<p>データ取得と最新データの反映するタイミングによって柔軟に実装できるようになっておくと良いだろう．</p>
<p>今回は以上である( `･ω･´)b</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
